# ${license-info}
# ${developer-info}
# ${author-info}
# ${build-info}
#
#
#
# This component is dedicated to LCG DPM (Disk Pool Manager) and
# LFC (Logical File Catalog) configuration management. It hs been designed
# to be very flexible and need no major change to handle changes in
# configuration file format, by using parsing rules to update the contents
# of configuration files. 
#
# Configuration files are modified only if their contents need to be changed,
# not at every run of the component. In case of changes, the services depending
# on the modified files are restared.
#
# Adding support for a new configuration variable should be pretty easy.
# Basically, if this is a role specific variable, you just need add a 
# parsing rule that use it in the %xxx_config_rules
# for the configuration file. If this is a global variable, you also need to
# load it from the configuration file as this is done for other configuration
# variables (at the beginning of Configure()). Look at the comments before
# %xxx_roles definitions to know about the parsing rules format.
#
# An effort has been made to document the code. Be sure to understand it before
# modifying.
#
# In case of problems, use --debug option of ncm-ncd. This will produce a lot
# of debugging information. 2 debugging levels are available (1, 2).
#
#######################################################################

package NCM::Component::${project.artifactId};

use strict;
use NCM::Component;
use vars qw(@ISA $EC);
@ISA = qw(NCM::Component);
$EC=LC::Exception::Context->new->will_store_all;

use EDG::WP4::CCM::Element;

use Readonly;

use File::Path;
use File::Copy;
use File::Compare;
use File::Basename;
use File::stat;

use LC::Check;
use CAF::FileWriter;
use CAF::FileEditor;
use CAF::Process;

use Encode qw(encode_utf8);
use Fcntl qw(SEEK_SET);

local(*DTA);

use Net::Domain qw(hostname hostfqdn hostdomain);


# Define paths for convenience. 
my $dm_install_root_default = "";

# Define some commands explicitly
my $chkconfig = "/sbin/chkconfig";
my $servicecmd = "/sbin/service";

my $dpm_def_host;

my $config_bck_ext = ".old";    # Replaced version extension
#my $config_prod_ext = ".new";    # For testing purpose only
my $config_prod_ext = "";    # For testing purpose only


# Backup file extension
use constant BACKUP_FILE_EXT => ".old";

# Constants use to format lines in configuration files
# Keep in sync with ncm-xrootd
use constant LINE_FORMAT_PARAM => 1;
use constant LINE_FORMAT_ENVVAR => 2;
use constant LINE_FORMAT_XRDCFG => 3;
use constant LINE_FORMAT_XRDCFG_SETENV => 4;
use constant LINE_FORMAT_XRDCFG_SET => 5;
use constant LINE_VALUE_AS_IS => 0;
use constant LINE_VALUE_BOOLEAN => 1;
use constant LINE_VALUE_HOST_LIST => 2;
use constant LINE_VALUE_INSTANCE_PARAMS => 3;
use constant LINE_VALUE_ARRAY => 4;
use constant LINE_VALUE_HASH_KEYS => 5;
use constant LINE_VALUE_STRING_HASH => 6;
use constant LINE_VALUE_OPT_NONE => 0;
use constant LINE_VALUE_OPT_SINGLE => 1;
use constant LINE_FORMAT_DEFAULT => LINE_FORMAT_PARAM;
use constant LINE_QUATTOR_COMMENT => "\t\t# Line generated by Quattor";
use constant LINE_OPT_DEF_REMOVE_IF_UNDEF => 0;
use constant LINE_OPT_DEF_ALWAYS_RULES_ONLY => 0;

# dpm and lfc MUST be the first element in their respective @xxx_roles array to 
# correctly apply defaults
# Role names used here must be the same as key in other hashes.
my @dpm_roles = (
     "copyd",
     "dav",
     "dpm",
     "dpns",
     "gsiftp",
     "rfio",
     "srmv1",
     "srmv2",
     "srmv22",
     "xroot",
    );
my @lfc_roles = (
     "lfc",
     "lfc-dli"
    );


# Following hash define the maximum supported servers for each type of servers
# Can be updated if redundancy is added for certain server types
my %dpm_comp_max_servers = (
          "copyd" => 1,
          "dav" => 999,
          "dpm" => 1,
          "dpns" => 1,
          "gsiftp" => 999,
          "rfio" => 999,
          "srmv1" => 1,
          "srmv2" => 1,
          "srmv22" => 1,
          "xroot" => 999,
         );

my %lfc_comp_max_servers = (
          "lfc" => 1,
          "lfc-dli" => 1,
         );


# Following hashes define parsing rules to build a configuration.
# Hash key is the line keyword in configuration file and 
# hash value is the parsing rule for the keyword value. Parsing rule format is :
#       [condition->]option_name:option_set[,option_set,...];line_fmt[;value_fmt]
#
# If the line keyword (hash key) is starting with a '-', this means that the matching
# configuration line must be removed/commented out (instead of added/updated) from the
# configuration file if present.
#
# 'condition': an option or an option set that must exist for the rule to be applied.
#              Both option_set and option_name:option_set are accepted (see below).
#              Only one option set is allowed and only existence, not value is tested.
#              In addition, the condition may be negated (option or option_set must
#              not exist) by prepending a '!' to it.
#
# 'option_name' is the name of an option that will be retrieved from the configuration
# 'option_set' is the set of options the option is located in (for example 'dpnsHost:dpm'
# means 'dpnsHost' option of 'dpm' option set. 'GLOBAL' is a special value for 'option_set'
# indicating that the option is a global option, instead of belonging to a specific option set.
#
# 'line_fmt' indicates the line format for the parameter : 3 formats are 
# supported :
#  - envvar : a sh shell environment variable definition (export VAR=val)
#  - param : a sh shell variable definition (VAR=val)
#  - xrdcfg : a 'keyword value' line, as used by Xrootd config files.
#  - xrdcfg_setenv : a 'setenv' line, as used by Xrootd config files.
#  - xrdcfg_set : a 'set' line, as used by Xrootd config files.
# Inline comments are not supported in xrdcfg family of formats.
# Line format has an impact on hosts list if there is one.
#
# 'value_fmt' allows special formatting of the value. This is mainly used for boolean
# values so that they are encoded as 'yes' or 'no'.
# If there are several servers for a role the option value from all the servers# is used for 'host' option, and only the server corresponding to current host
# for other options.
#
# NOTE: DPM_HOST/DPNS_HOST are added exported as some components require this in recent DPM versions (1.8.8+).
#       Unfortunately, the sysconfig template file provided in the RPM has an uncommented unexported version of the
#       variables which is not syntactically correct (suggested value between <>). It is necessary to comment this line
#       in addition to defining the exported variable. This is done by prefixing the variable name with a '-'.
#       If this is not done, the resulting sysconfig file may contain syntax errors preventing the correct daemon operations.
my $copyd_config_file = "/etc/sysconfig/dpmcopyd";
my %copyd_config_rules = (
        "ALLOW_COREDUMP" => "allowCoreDump:copyd;".LINE_FORMAT_PARAM.";".LINE_VALUE_BOOLEAN,
        "-DPM_HOST" => "host:dpm;".LINE_FORMAT_PARAM,
        "DPM_HOST" => "host:dpm;".LINE_FORMAT_ENVVAR,
        "-DPNS_HOST" => "host:dpns;".LINE_FORMAT_PARAM,
        "DPNS_HOST" => "host:dpns;".LINE_FORMAT_ENVVAR,
        "DPMCONFIGFILE" => "dbconfigfile:GLOBAL;".LINE_FORMAT_PARAM,
        "DPMCOPYDLOGFILE" => "logfile:copyd;".LINE_FORMAT_PARAM,
        #"DPMCOPYD_PORT" => "port:copyd;".LINE_FORMAT_PARAM,
        #"DPMGROUP" => "group:GLOBAL;".LINE_FORMAT_PARAM,
        ##"DPMUSER" => "user:GLOBAL;".LINE_FORMAT_PARAM,
        "GRIDMAP" => "gridmapfile:GLOBAL;".LINE_FORMAT_PARAM,
        "GRIDMAPDIR" => "gridmapdir:GLOBAL;".LINE_FORMAT_PARAM,
        "RUN_DPMCOPYDAEMON" => "ALWAYS->role_enabled:copyd;".LINE_FORMAT_PARAM.";".LINE_VALUE_BOOLEAN,
        "ULIMIT_N" => "maxOpenFiles:copyd;".LINE_FORMAT_PARAM,
        "GLOBUS_THREAD_MODEL" => "globusThreadModel:copyd;".LINE_FORMAT_ENVVAR,
       );

my $dav_config_file = "/etc/httpd/conf.d/zlcgdm-dav.conf";
my %dav_config_rules = (
        "DiskFlags" =>"DiskFlags:dav;".LINE_FORMAT_XRDCFG.";".LINE_VALUE_ARRAY,
        "NSFlags" =>"NSFlags:dav;".LINE_FORMAT_XRDCFG.";".LINE_VALUE_ARRAY,
);

my $dpm_config_file = "/etc/sysconfig/dpm";
my %dpm_config_rules = (
      "ALLOW_COREDUMP" => "allowCoreDump:dpm;".LINE_FORMAT_PARAM.";".LINE_VALUE_BOOLEAN,
      "-DPM_HOST" => "host:dpm;".LINE_FORMAT_PARAM,
      "DPM_HOST" => "host:dpm;".LINE_FORMAT_ENVVAR,
      "-DPNS_HOST" => "host:dpns;".LINE_FORMAT_PARAM,
      "DPNS_HOST" => "host:dpns;".LINE_FORMAT_ENVVAR,
      "DPMCONFIGFILE" => "dbconfigfile:GLOBAL;".LINE_FORMAT_PARAM,
      "DPMDAEMONLOGFILE" => "logfile:dpm;".LINE_FORMAT_PARAM,
      #"DPMGROUP" => "group:GLOBAL;".LINE_FORMAT_PARAM,
      #"DPMUSER" => "user:GLOBAL;".LINE_FORMAT_PARAM,
      #"DPM_PORT" => "port:dpm;".LINE_FORMAT_PARAM,
      "DPM_USE_SYNCGET" => "useSyncGet:dpm;".LINE_FORMAT_PARAM.";".LINE_VALUE_BOOLEAN,
      "GRIDMAPDIR" => "gridmapdir:GLOBAL;".LINE_FORMAT_PARAM,
      "NB_FTHREADS" => "fastThreads:dpm;".LINE_FORMAT_PARAM,
      "NB_STHREADS" => "slowThreads:dpm;".LINE_FORMAT_PARAM,
      "RUN_DPMDAEMON" => "ALWAYS->role_enabled:dpm;".LINE_FORMAT_PARAM.";".LINE_VALUE_BOOLEAN,
      "ULIMIT_N" => "maxOpenFiles:dpm;".LINE_FORMAT_PARAM,
      "GLOBUS_THREAD_MODEL" => "globusThreadModel:dpm;".LINE_FORMAT_ENVVAR,
           );

my $dpns_config_file = "/etc/sysconfig/dpnsdaemon";
my %dpns_config_rules = (
       "ALLOW_COREDUMP" => "allowCoreDump:dpns;".LINE_FORMAT_PARAM.";".LINE_VALUE_BOOLEAN,
       "-DPM_HOST" => "host:dpm;".LINE_FORMAT_PARAM,
       "DPM_HOST" => "host:dpm;".LINE_FORMAT_ENVVAR,
       "-DPNS_HOST" => "host:dpns;".LINE_FORMAT_PARAM,
       "DPNS_HOST" => "host:dpns;".LINE_FORMAT_ENVVAR,
       #"DPMGROUP" => "group:GLOBAL;".LINE_FORMAT_PARAM,
       #"DPMUSER" => "user:GLOBAL;".LINE_FORMAT_PARAM,
       "DPNSDAEMONLOGFILE" => "logfile:dpns;".LINE_FORMAT_PARAM,
       #"DPNS_PORT" => "port:dpns;".LINE_FORMAT_PARAM,
       "NB_THREADS" => "threads:dpns;".LINE_FORMAT_PARAM,
       "NSCONFIGFILE" => "dbconfigfile:GLOBAL;".LINE_FORMAT_PARAM,
       "RUN_DPNSDAEMON" => "ALWAYS->role_enabled:dpns;".LINE_FORMAT_PARAM.";".LINE_VALUE_BOOLEAN,
       "RUN_READONLY" => "readonly:dpns;".LINE_FORMAT_PARAM.";".LINE_VALUE_BOOLEAN,
       "ULIMIT_N" => "maxOpenFiles:dpns;".LINE_FORMAT_PARAM,
       "GLOBUS_THREAD_MODEL" => "globusThreadModel:dpns;".LINE_FORMAT_ENVVAR,
      );

my $gsiftp_config_file = "/etc/sysconfig/dpm-gsiftp";
my %gsiftp_config_rules = (
         "-DPM_HOST" => "host:dpm;".LINE_FORMAT_PARAM,
         "DPM_HOST" => "host:dpm;".LINE_FORMAT_ENVVAR,
         "-DPNS_HOST" => "host:dpns;".LINE_FORMAT_PARAM,
         "DPNS_HOST" => "host:dpns;".LINE_FORMAT_ENVVAR,
         "FTPLOGFILE" => "logfile:gsiftp;".LINE_FORMAT_PARAM,
         "GLOBUS_TCP_PORT_RANGE" => "portRange:gsiftp;".LINE_FORMAT_PARAM,
         "OPTIONS" => "startupOptions:gsiftp;".LINE_FORMAT_PARAM,
         "RUN_DPMFTP" => "ALWAYS->role_enabled:gsiftp;".LINE_FORMAT_PARAM.";".LINE_VALUE_BOOLEAN,
        );

my $rfio_config_file = "/etc/sysconfig/rfiod";
my %rfio_config_rules = (
       "-DPM_HOST" => "host:dpm;".LINE_FORMAT_PARAM,
       "DPM_HOST" => "host:dpm;".LINE_FORMAT_ENVVAR,
       "-DPNS_HOST" => "host:dpns;".LINE_FORMAT_PARAM,
       "DPNS_HOST" => "host:dpns;".LINE_FORMAT_ENVVAR,
       "GRIDMAPDIR" => "gridmapdir:GLOBAL;".LINE_FORMAT_PARAM,
       "OPTIONS" => "startupOptions:rfio;".LINE_FORMAT_PARAM,
       "RFIOLOGFILE" => "logfile:rfio;".LINE_FORMAT_PARAM,
       "RFIO_PORT_RANGE" => "portRange:rfio;".LINE_FORMAT_PARAM,
       "RUN_RFIOD" => "ALWAYS->role_enabled:rfio;".LINE_FORMAT_PARAM.";".LINE_VALUE_BOOLEAN,
       "ULIMIT_N" => "maxOpenFiles:rfio;".LINE_FORMAT_PARAM,
       );

my $srmv1_config_file = "/etc/sysconfig/srmv1";
my %srmv1_config_rules = (
        "ALLOW_COREDUMP" => "allowCoreDump:srmv1;".LINE_FORMAT_PARAM.";".LINE_VALUE_BOOLEAN,
        "DPMCONFIGFILE" => "dbconfigfile:GLOBAL;".LINE_FORMAT_PARAM,
        #"DPMGROUP" => "group:GLOBAL;".LINE_FORMAT_PARAM,
        #"DPMUSER" => "user:GLOBAL;".LINE_FORMAT_PARAM,
        "-DPM_HOST" => "host:dpm;".LINE_FORMAT_PARAM,
        "DPM_HOST" => "host:dpm;".LINE_FORMAT_ENVVAR,
        "-DPNS_HOST" => "host:dpns;".LINE_FORMAT_PARAM,
        "DPNS_HOST" => "host:dpns;".LINE_FORMAT_ENVVAR,
        "GRIDMAP" => "gridmapfile:GLOBAL;".LINE_FORMAT_PARAM,
        "GRIDMAPDIR" => "gridmapdir:GLOBAL;".LINE_FORMAT_PARAM,
        "RUN_SRMV1DAEMON" => "ALWAYS->role_enabled:srmv1;".LINE_FORMAT_PARAM.";".LINE_VALUE_BOOLEAN,
        "SRMV1DAEMONLOGFILE" => "logfile:srmv1;".LINE_FORMAT_PARAM,
        #"SRMV1_PORT" => "port:srmv1;".LINE_FORMAT_PARAM,
        "ULIMIT_N" => "maxOpenFiles:srmv1;".LINE_FORMAT_PARAM,
        "GLOBUS_THREAD_MODEL" => "globusThreadModel:srmv1;".LINE_FORMAT_ENVVAR,
       );

my $srmv2_config_file = "/etc/sysconfig/srmv2";
my %srmv2_config_rules = (
        "ALLOW_COREDUMP" => "allowCoreDump:srmv2;".LINE_FORMAT_PARAM.";".LINE_VALUE_BOOLEAN,
        "DPMCONFIGFILE" => "dbconfigfile:GLOBAL;".LINE_FORMAT_PARAM,
        #"DPMGROUP" => "group:GLOBAL;".LINE_FORMAT_PARAM,
        #"DPMUSER" => "user:GLOBAL;".LINE_FORMAT_PARAM,
        "-DPM_HOST" => "host:dpm;".LINE_FORMAT_PARAM,
        "DPM_HOST" => "host:dpm;".LINE_FORMAT_ENVVAR,
        "-DPNS_HOST" => "host:dpns;".LINE_FORMAT_PARAM,
        "DPNS_HOST" => "host:dpns;".LINE_FORMAT_ENVVAR,
        "GRIDMAP" => "gridmapfile:GLOBAL;".LINE_FORMAT_PARAM,
        "GRIDMAPDIR" => "gridmapdir:GLOBAL;".LINE_FORMAT_PARAM,
        "RUN_SRMV2DAEMON" => "ALWAYS->role_enabled:srmv2;".LINE_FORMAT_PARAM.";".LINE_VALUE_BOOLEAN,
        "SRMV2DAEMONLOGFILE" => "logfile:srmv2;".LINE_FORMAT_PARAM,
        #"SRMV2_PORT" => "port:srmv2;".LINE_FORMAT_PARAM,
        "ULIMIT_N" => "maxOpenFiles:srmv2;".LINE_FORMAT_PARAM,
        "GLOBUS_THREAD_MODEL" => "globusThreadModel:srmv2;".LINE_FORMAT_ENVVAR,
       );

my $srmv22_config_file = "/etc/sysconfig/srmv2.2";
my %srmv22_config_rules = (
        "ALLOW_COREDUMP" => "allowCoreDump:srmv22;".LINE_FORMAT_PARAM.";".LINE_VALUE_BOOLEAN,
        "DPMCONFIGFILE" => "dbconfigfile:GLOBAL;".LINE_FORMAT_PARAM,
        #"DPMGROUP" => "group:GLOBAL;".LINE_FORMAT_PARAM,
        #"DPMUSER" => "user:GLOBAL;".LINE_FORMAT_PARAM,
        "-DPM_HOST" => "host:dpm;".LINE_FORMAT_PARAM,
        "DPM_HOST" => "host:dpm;".LINE_FORMAT_ENVVAR,
        "-DPNS_HOST" => "host:dpns;".LINE_FORMAT_PARAM,
        "DPNS_HOST" => "host:dpns;".LINE_FORMAT_ENVVAR,
        "GRIDMAP" => "gridmapfile:GLOBAL;".LINE_FORMAT_PARAM,
        "GRIDMAPDIR" => "gridmapdir:GLOBAL;".LINE_FORMAT_PARAM,
        "NB_THREADS" => "threads:srmv22;".LINE_FORMAT_PARAM,
        "RUN_SRMV2DAEMON" => "ALWAYS->role_enabled:srmv22;".LINE_FORMAT_PARAM.";".LINE_VALUE_BOOLEAN,
        "SRMV22DAEMONLOGFILE" => "logfile:srmv22;".LINE_FORMAT_PARAM,
        #"SRMV2_2_PORT" => "port:srmv22;".LINE_FORMAT_PARAM,
        "ULIMIT_N" => "maxOpenFiles:srmv22;".LINE_FORMAT_PARAM,
        "GLOBUS_THREAD_MODEL" => "globusThreadModel:srmv22;".LINE_FORMAT_ENVVAR,
       );

my $trust_roles = "dpm,dpns,rfio,gsiftp";
my $trust_config_file = "/etc/shift.conf";
my %trust_config_rules = (
        "DPM PROTOCOLS" => "accessProtocols:GLOBAL;".LINE_FORMAT_XRDCFG,
        "DPM TRUST" => "dpm->host:dpns,xroot;".LINE_FORMAT_XRDCFG,
        "DPNS TRUST" => "dpns->host:dpm,srmv1,srmv2,srm22,rfio;".LINE_FORMAT_XRDCFG,
        "RFIOD TRUST" => "rfio->host:dpm,rfio;".LINE_FORMAT_XRDCFG,
        "RFIOD WTRUST" => "rfio->host:dpm,rfio;".LINE_FORMAT_XRDCFG,
        "RFIOD RTRUST" => "rfio->host:dpm,rfio;".LINE_FORMAT_XRDCFG,
        "RFIOD XTRUST" => "rfio->host:dpm,rfio;".LINE_FORMAT_XRDCFG,
        "RFIOD FTRUST" => "rfio->host:dpm,rfio;".LINE_FORMAT_XRDCFG,
        "RFIO DAEMONV3_WRMT 1" => ";".LINE_FORMAT_XRDCFG,
        "DPM REQCLEAN" => "dpm->requestMaxAge:dpm;".LINE_FORMAT_XRDCFG,
       );

my $lfc_config_file = "/etc/sysconfig/lfcdaemon";
my %lfc_config_rules = (
      "LFCDAEMONLOGFILE" => "logfile:lfc",
      #"LFCGROUP" => "group:GLOBAL;".LINE_FORMAT_PARAM,
      #"LFC_PORT" => "port:lfc;".LINE_FORMAT_ENVVAR,
      #"LFCUSER" => "user:GLOBAL;".LINE_FORMAT_PARAM,
      "NB_THREADS" => "threads:lfc;".LINE_FORMAT_PARAM,
      "NSCONFIGFILE" => "dbconfigfile:GLOBAL;".LINE_FORMAT_PARAM,
      "RUN_DISABLEAUTOVIDS" => "disableAutoVirtualIDs:lfc;".LINE_FORMAT_PARAM.";".LINE_VALUE_BOOLEAN,
      "RUN_LFCDAEMON" => "ALWAYS->role_enabled:lfc;".LINE_FORMAT_PARAM.";".LINE_VALUE_BOOLEAN,
      "RUN_READONLY" => "readonly:lfc;".LINE_FORMAT_PARAM.";".LINE_VALUE_BOOLEAN,
      "ULIMIT_N" => "maxOpenFiles:lfc;".LINE_FORMAT_PARAM,
           );

my $lfcdli_config_file = "/etc/sysconfig/lfc-dli";
my %lfcdli_config_rules = (
         "DLIDAEMONLOGFILE" => "logfile:lfc-dli",
         #"DLI_PORT" => "port:lfc-dli;".LINE_FORMAT_ENVVAR,
         "GRIDMAP" => "gridmapfile:GLOBAL;".LINE_FORMAT_PARAM,
         "GRIDMAPDIR" => "gridmapdir:GLOBAL;".LINE_FORMAT_PARAM,
         #"LFCGROUP" => "group:GLOBAL;".LINE_FORMAT_PARAM,
         "LFC_HOST" => "host:lfc",
         #"LFCUSER" => "user:GLOBAL;".LINE_FORMAT_PARAM,
         "RUN_DLIDAEMON" => "ALWAYS->role_enabled:lfc-dli;".LINE_FORMAT_PARAM.";".LINE_VALUE_BOOLEAN,
         "ULIMIT_N" => "maxOpenFiles:lfc-dli;".LINE_FORMAT_PARAM,
        );

my %config_files = (
        "copyd" => \$copyd_config_file,
        "dav" => \$dav_config_file,
        "dpm" => \$dpm_config_file,
        "dpns" => \$dpns_config_file,
        "gsiftp" => \$gsiftp_config_file,
        "rfio" => \$rfio_config_file,
        "srmv1" => \$srmv1_config_file,
        "srmv2" => \$srmv2_config_file,
        "srmv22" => \$srmv22_config_file,
        "trusts" => \$trust_config_file,
        "lfc" => \$lfc_config_file,
        "lfc-dli" => \$lfcdli_config_file,
       );

my %config_rules = (
        "copyd" => \%copyd_config_rules,
        "dav" => \%dav_config_rules,
        "dpm" => \%dpm_config_rules,
        "dpns" => \%dpns_config_rules,
        "gsiftp" => \%gsiftp_config_rules,
        "rfio" => \%rfio_config_rules,
        "srmv1" => \%srmv1_config_rules,
        "srmv2" => \%srmv2_config_rules,
        "srmv22" => \%srmv22_config_rules,
        "trusts" => \%trust_config_rules,
        "lfc" => \%lfc_config_rules,
        "lfc-dli" => \%lfcdli_config_rules,
       );
       

# Define services using each role/configuration file (if any), with each service
# separated by a comma. Services will be restarted once even if they have
# multiple dependencies.
# If service list is prefixed by 'role:', list is a name of role that is
# present in this list (take care not to create a loop).
# 'trusts' is a special entry associated with modifications of /etc/shift.conf.
# Service will be restarted if configuration changes.
my %services = (
    "copyd" => "dpmcopyd",
    "dav" => "httpd",
    "dpm" => "dpm",
    "dpns" => "dpnsdaemon",
    "gsiftp" => "dpm-gsiftp",
    "rfio" => "rfiod",
    "srmv1" => "srmv1",
    "srmv2" => "srmv2",
    "srmv22" => "srmv2.2",
    "lfc" => "lfcdaemon",
    "lfc-dli" => "lfc-dli",
    #"trusts" => "role:dpm,dpns,gsiftp,rfio,xroot",   # shift.conf modifications are automaticaly detected without a need to restart daemons
         );


# Define nameserver role in each product
my %nameserver_role = (
                       "DPM", "dpns",
                       "LFC", "lfc",
                      );

# Define roles needing access to database
my %db_roles = (
    "DPM" => "dpm,dpns",
    "LFC" => "lfc",
         );


# Define file where is stored DB connection information
my %db_conn_config = (
          "DPM" => "/etc/DPMCONFIG",
          "LFC" => "/etc/NSCONFIG",
         );
my %db_conn_config_mode = (
          "DPM" => "600",
          "LFC" => "600",
         );

my %db_servers;

my %users_def = (
        "DPM" => "dpmmgr",
        "LFC" => "lfcmgr",
       );

# Security related defaults
my $grid_security_dir = "/etc/grid-security";
my $gridmapdir_def = $grid_security_dir."/gridmapdir";
my $hostkey = "hostkey.pem";
my $hostcert = "hostcert.pem";
my %nonroot_roles = (
         "DPM" => "copyd,dpm,dpns,srmv1,srmv2,srmv22",
         "LFC" => "lfc,lfc-dli",
        );


# GIP user configuration path
Readonly my $GIP2_USER_PAN_PATH => "/software/components/gip2/user";

my @products = ("DPM", "LFC");

my $this_host_full;
my $this_host_domain;

# Global variables to store component configuration
my $config_options;

# Global context variables used by functions
my $dm_install_root;
my $dm_bin_dir;

# dpmlfc configuration
my $dpmlfc_config;


# GIP user
my $gip_user;

##########################################################################
sub Configure {
##########################################################################
    
  my ( $self, $config) = @_;
  
  my $current_node_fqdn = join ".", hostname(), hostdomain();

  return $self->configureNode($current_node_fqdn, $config);
}


##########################################################################
# Do the real work here: the only reason for this method is to allow
# testing by mocking the hostname.
#
# Arguments
#     host_fqdn: FQDN of the host to configure
#     profile: host profile (this component needs more than dpmlfc config)
sub configureNode {
##########################################################################
    
  my ( $self, $host_fqdn, $profile) = @_;
  unless ( $host_fqdn && $profile ) {
    $self->error("configureNode: missing argument (internal error)");
    return (2);
  }

  $this_host_full = $host_fqdn;
  (my $this_host_name, $this_host_domain) = split /\./, $this_host_full, 2;

  $dpmlfc_config = $profile->getElement($self->prefix())->getTree();
  if ( $profile->elementExists($GIP2_USER_PAN_PATH) ) {
    $gip_user = $profile->getElement($GIP2_USER_PAN_PATH)->getValue();
  }

  # Process separatly DPM and LFC configuration
  
  my $comp_max_servers;
  for my $product (@products) {
    # Initialize options hash for the current product.
    # Options hash contains global options and one sub-hash for each role.
    # Sub-hash for each contains the options for the current host and the role host list.
    $config_options = {};

    # Establish context for other functions
    $self->defineCurrentProduct($product);

    $dm_install_root = $self->getGlobalOption("installDir");
    unless ( defined($dm_install_root) ) {
      $dm_install_root = $dm_install_root_default;
    }
    $config_options->{installDir} = $dm_install_root;
    if ((length($dm_install_root) == 0) || ($dm_install_root eq "/")) {
      $dm_install_root = "";
      $dm_bin_dir = "/usr/bin";
    } else {
      $dm_bin_dir = $dm_install_root . "/bin";      
    }
    
    my $hosts_roles;
    if ( $product eq "DPM" ) {
      $hosts_roles = \@dpm_roles;
      $comp_max_servers = \%dpm_comp_max_servers;
    } else {
      $hosts_roles = \@lfc_roles;
      $comp_max_servers = \%lfc_comp_max_servers;
    }

    # Check that the product is configured, else there is no point in doing
    # what follows, even though this is mainly harmless.
    my $product_configured = 0;
    foreach my $role (@$hosts_roles) {
      if ( exists($dpmlfc_config->{$role}) ) {
        $product_configured = 1; 
        last;  
      }
    }
    if ( ! $product_configured ) {
      $self->debug(1,"Product $product not configured: skipping its configuration");
      next;  
    }

    # Retrieve some general options
    # Don't define 'user' global option with a default value to keep it
    # undefined during rules processing

    if ( defined($self->getGlobalOption("user")) ) {
      $config_options->{user} = $self->getGlobalOption("user");
    }
    if ( defined($self->getGlobalOption("group")) ) {
      $config_options->{user} = $self->getGlobalOption("group");
    }
    if ( defined($self->getGlobalOption("gridmapfile")) ) {
      $config_options->{user} = $self->getGlobalOption("gridmapfile");
    }
    if ( defined($self->getGlobalOption("gridmapdir")) ) {
      $config_options->{user} = $self->getGlobalOption("gridmapdir");
    }
    if ( defined($self->getGlobalOption("accessProtocols")) ) {
      $config_options->{user} = $self->getGlobalOption("accessProtocols");
    }
    if ( defined($self->getGlobalOption("controlProtocols")) ) {
      $config_options->{user} = $self->getGlobalOption("controlProtocols");
    }


    # Define with product default value if not specified
    if ( my $v = $self->getDbOption('configfile') ) {
      $config_options->{dbconfigfile} = $v;
      $self->debug(1,"Global option 'dbconfigfile' defined to ".$config_options->{dbconfigfile});
    } else {
      $config_options->{dbconfigfile} = $db_conn_config{$product};
      $self->debug(1,"Global option 'dbconfigfile' set to default : ".$config_options->{dbconfigfile});
    }
    if ( my $v = $self->getDbOption('configmode') ) {
      $config_options->{dbconfigmode} = $v;
      $self->debug(1,"Global option 'dbconfigmode' defined to ".$config_options->{dbconfigmode});
    } else {
      $config_options->{dbconfigmode} = $db_conn_config_mode{$product};
      $self->debug(1,"Global option 'dbconfigmode' set to default : ".$config_options->{dbconfigmode});
    }

    # At least $dpmlfc_config->{dpm} or $dpmlfc_config->{lfc} must exist

    my @actual_hosts_roles;
    my $role_host_list = {};
    for my $role (@$hosts_roles) {
      # By default, assume this role is disabled on local host.
      # Temporarily, define the option in global options.
      $config_options->{$role."_service_enabled"} = 0;
      if ( exists($dpmlfc_config->{$role}) ) {
        push @actual_hosts_roles, $role;
        my $servers = $dpmlfc_config->{$role};
        if ( keys(%{$servers}) <= ${$comp_max_servers}{$role} ) {
          my $def_host;
          for my $role_host (keys(%{$servers})) {
            if ( ($role eq "dpm") || ($role eq "lfc") ) {
              if ( $role eq "lfc" ){
                if ( exists($dpmlfc_config->{"dpns"}) ) {
                  $self->error("LFC server and DPNS server cannot be run on the same node. Skipping LFC configuration.");
                  return 0;
                }
              }
            }
            $role_host_list->{$role}->{$role_host} = '';            
            if ( $role_host eq $this_host_full ) {
              $config_options->{$role."_service_enabled"} = 1;
            }
          }
        } else {
          $self->error("Too many ".uc($role)." servers (maximum=${$comp_max_servers}{$role})");
          return 0;
        }
      }
    }

    # Retrieve from profile configuration about roles.
    # For each role retrieve the role configuration for this host if it is in the role list,
    # else the information from the first host in the list. In addition, add role host list and
    # copy the role enabled info from global options to role options.
    for my $role (@$hosts_roles) {
      if ( grep(/^$role$/,@actual_hosts_roles) ) {
        my @role_hosts = sort(keys(%{$role_host_list->{$role}}));
        if ( @role_hosts ) {
          # Use first host with  this role if current host is not enabled for
          # the role. Not really sensible to refer a host specific configuration
          # for a role not executed on the local host.
          my $h;
          if ( exists($dpmlfc_config->{$role}->{$this_host_full}) ) {
            $h = $this_host_full;
            $self->debug(2,"Host $this_host_full supporting role $role: using its configuration");
          } else {              
            $h = $role_hosts[0];
            $self->debug(2,"Host $this_host_full not found in role $role: using configuration from host $h");
          }
          $config_options->{$role} = $self->getHostConfig($role,$h);
          $config_options->{$role}->{hostlist} = \@role_hosts;
          # 'host' contains the name of role host whose config has been used.
          # For roles with a max of 1 host (e.g. dpm, dpns), this is the host name serving the role.
          $config_options->{$role}->{host} = $h;
        } else {
          $self->error("Internal error: no host with role ".uc($role)." found");
        }
      }
      $config_options->{$role}->{role_enabled} = $config_options->{$role.'_service_enabled'};
      delete $config_options->{$role.'_service_enabled'};
      $self->debug(3,"Keys in $role options: ".join(",",keys(%{$config_options->{$role}})));
    }
    $self->debug(3,"Keys in config_options: ".join(",",keys(%{$config_options})));

    # Update configuration files for every configured role.
    # xroot is a special case as it is managed by a separate component, ncm-xrootd.
    for my $role (@{$hosts_roles}) {
      if ( $role ne 'xroot' ) {
        if ( $self->hostHasRoles($role) ) {
          $self->info("Checking configuration for ".$role);
          $self->updateRoleConfig($role,$config_options);
          for my $service ($self->getRoleServices($role)) {
            $self->enableService($service);
          }
        } else {
          $self->info("Checking that role ".$role." is disabled...");        
          $self->updateRoleConfig($role,$config_options);
        }
      }
    }

    if ( $product eq "DPM" ) {
      $self->updateRoleConfig("trusts",$config_options) if $self->hostHasRoles($trust_roles);
    }

    # Build init script to control all enabled services
    $self->buildEnabledServiceInitScript();

    # Do necessary DB initializations (only if current host has one role needing
    # DB access
    if ( $self->hostHasRoles($db_roles{$product}) ) {
      $self->info("Checking ".$self->getCurrentProduct()." database configuration...");
      my $status = $self->createDbConfigFile();
      # Negative status means success with changes requiring services restart
      if ( $status < 0 ) {
        for my $role_to_restart ($db_roles{$product}) {
          $self->serviceRestartNeeded($role_to_restart);
        }
      }
    }


    # Check permissions on grid-security directories if some daemons not running
    # as root are configured on the local machine.
    # These changes don't require a service restart.
    # Running both LFC and DPM related non root daemons on the same machine
    # if they don't use the same group may lead to configuration conflict
    # on gridmapdir permissions
    my @roles_nonroot = split /\s*,\s*/, $nonroot_roles{$product};
    for my $role (@roles_nonroot) {
      if ( $self->hostHasRoles($role) ) {
        $self->checkSecurity();
        last;    # Do only once for all the roles
      }
    }

  }

  # Restart services that need to be (DPM/LFC services are stateless).
  # Don't signal error as it has already been signaled by restartServices().
  if ( $self->restartServices() ) {
    return(1);
  }


  # If product is DPM and current node is DPNS server or if product is LFC and
  # this node runs lfc daemon, do namespace configuration for VOs
  for my $product (@products) {
    $self->defineCurrentProduct($product);
    if ( $self->hostHasRoles($nameserver_role{$product}) ) {
      $self->info("Checking namespace configuration for supported VOs...");
      $self->NSRootConfig();
      if ( exists($dpmlfc_config->{vos}) ) {
        my $vos = $dpmlfc_config->{vos};
        for my $vo (sort(keys(%$vos))) {
          # A VO may be present without any specific setting
          my %vo_args;
          if ( ref($vos->{$vo}) eq "HASH" ) {
            %vo_args = %{$vos->{$vo}};
          }
          $self->NSConfigureVO($vo,%vo_args);
        }
      }
    }
  }


  # If the current node is a DPM server (running dpm daemon) and pool configuration
  # is present in the profile, configure pools.
  $self->defineCurrentProduct("DPM");
  if ( $self->hostHasRoles('dpm') ) {
    if ( exists($dpmlfc_config->{pools}) ) {
      my $pools = $dpmlfc_config->{pools};
      for my $pool (sort(keys(%$pools))) {
        my $pool_args = %{$pools->{$pool}};
        $self->DPMConfigurePool($pool,$pool_args);
      }
    }
  }

  return 0;
}


# Function to configure DPM pools
# Returns 0 if the pool already exists or has been configured successfully, else error code of 
# the failed command.
# No attempt is made to modify an existing pool.
sub DPMConfigurePool () {
  my $function_name = "DPMConfigurePool";
  my $self = shift;
  my $status = 0;
  my $pool_name;
  if ( @_ > 0 ) {
    $pool_name = shift;
  } else {
    $self->error("$function_name: pool name argument missing.");
    return (1);
  }
  my $pool_args;
  if ( @_ > 0 ) {
    $pool_args = shift;
  } else {
    $self->error("$function_name: pool properties argument missing.");
    return (1);
  }
    
  my $product = $self->getCurrentProduct();

  $self->info('Pool configuration not yet implemented');
  
  return($status);
}

# Function to check if a directory already exists in namespace
# Returns 0 if the directory already exists, -1 if not, error code
# if namespace command returned another error.

sub NSCheckDir () {
  my $function_name = "NSCheckDir";
  my $self = shift;
  my $directory;
  if ( @_ > 0 ) {
    $directory = shift;
  } else {
    $self->error("$function_name: directory argument missing.");
    return (1);
  }
  
  my $product = $self->getCurrentProduct();

  my $cmd;
  if ( $product eq 'DPM' ) {
    $ENV{DPNS_HOST} = $this_host_full;
    $cmd = $dm_bin_dir.'/dpns-ls';
  }else {
    $ENV{LFC_HOST} = $this_host_full;
    $cmd = $dm_bin_dir.'/lfc-ls';
  }
  $cmd .= ' '.$directory;

  $self->debug(1,"$function_name: checking if directory $directory exists in $product namespace");

  my $errormsg='';
  my $status = $self->execCmd($cmd, \$errormsg);
  if ( $status ) {
    $self->debug(1,"$function_name: directory $directory not found ($cmd status=$status, error=$errormsg)");
  } else {
    $self->debug(1,"$function_name: directory $directory found");
  }
  
  return($status);
}

# Function to configure namespace root (/dpm/domain/home for DPM, /grid for LFC).
# Returns 0 if already configured or if configuration has been done successfully.
# Root is considered already configured if it exists (permission/ACL not checked).

sub NSRootConfig () {
  my $function_name = "NSRootConfig";
  my $self = shift;
  my $status = 0;
  
  my $product = $self->getCurrentProduct();

  my $root = $self->NSGetRoot();

  $self->debug(1,"$function_name: checking NS root ($root) configuration for $product");

  # Check if root already exists.
  # Do it recursively starting from DPM root up to top level parent.
  # First identify the first missing level and then create missing levels.

  # root_toks[0] is empty as root begins by /  
  my @root_toks = split /\//, $root;
  my $ns_root_ok = 1;
  my $tok_ok;
  for ($tok_ok=@root_toks-1; $tok_ok>0; $tok_ok--) {
    my $path;
    for (my $j=1; $j<=$tok_ok; $j++) {
      $path .= '/'.$root_toks[$j];
    }
    $self->debug(2,"$function_name: checking $path");
    if ( $self->NSCheckDir($path) ) {
      $self->debug(1,"$function_name: $path missing");
      $ns_root_ok = 0;
    } else {
      last;
    }
  }

  if ( ! $ns_root_ok ) {
    for (my $i=$tok_ok+1; $i<@root_toks; $i++) {
      my $path;
      for (my $j=1; $j<=$i; $j++) {
        $path .= '/'.$root_toks[$j];
      }
      $status = $self->execNSCmd("mkdir $path");
      if ( $status ) {
        $self->error("Error creating $path");
        return(2);
      }
      $status = $self->execNSCmd("chmod 775 $path");
      if ( $status ) {
        $self->error("Error defining $path permissions");
        return(2);
      }
      $status = $self->execNSCmd("setacl -m d:u::7,d:g::7,d:o:5 $path");
      if ( $status ) {
        $self->error("Error defining $path ACL");
        return(2);
      }
    }
    $self->info("Namespace root ($root) for $product initialized");
  }
    
  return($status);
}


# Function to configure namespace for a VO. Namespace root must have been configured
# before (NSRootConfig()).
# Returns 0 if already configured or if configuration has been done successfully.
# Root is considered already configured if it exists (permission/ACL not checked).

sub NSConfigureVO () {
  my $function_name = "NSConfigureVO";
  my $self = shift;
  my $status = 0;
  my $vo_name;
  if ( @_ > 0 ) {
    $vo_name = shift;
  } else {
    $self->error("$function_name: VO name argument missing.");
    return (1);
  }
  my %vo_args;
  if ( @_ > 0 ) {
    %vo_args = shift;
  }
    
  my $product = $self->getCurrentProduct();

  my $vo_home = $self->NSGetRoot().'/'.$vo_name;

  $self->debug(1,"$function_name: checking VO $vo_name NS configuration ($vo_home) for $product");

  # Check if VO home already exists. Create and configure it if not.

  if ( $self->NSCheckDir($vo_home) ) {
    $self->debug(1,"$function_name: $vo_home missing");

    my $gid_option = '';
    if ( defined($vo_args{gid}) ) {
      $gid_option = '--gid '.$vo_args{gid};
    }
    $status = $self->execNSCmd("entergrpmap --group $vo_name $gid_option");
    if ( $status ) {
      $self->debug(1,"Error creating virtual GID for VO $vo_name : probably already exists.");
    }    
    $status = $self->execNSCmd("mkdir $vo_home");
    if ( $status ) {
      $self->error("Error creating $vo_home");
      return(2);
    }
    $status = $self->execNSCmd("chown root:$vo_name $vo_home");
    if ( $status ) {
      $self->error("Error setting owner for $vo_home");
      return(2);
    }
    $status = $self->execNSCmd("chmod 775 $vo_home");
    if ( $status ) {
      $self->error("Error defining $vo_home permissions");
      return(2);
    }
    $status = $self->execNSCmd("setacl -m d:u::7,d:g::7,d:o:5 $vo_home");
    if ( $status ) {
      $self->error("Error defining $vo_home ACL");
      return(2);
    }
    $self->info("VO $vo_name namespace ($vo_home) for $product initialized");
  }
    
  return($status);
}


# Function returning the namespace root according to the currently selected product
sub NSGetRoot () {
  my $function_name = "NSGetRoot";
  my $self = shift;
  
  my $product = $self->getCurrentProduct();

  $self->debug(2,"$function_name: returning namespace root for $product");

  my $root;
  if ( $product eq 'DPM' ) {
    $root = '/dpm/'.$this_host_domain.'/home';
  }else {
    $root = '/grid';
  }
 
  return($root);
}


# Function to execute a nameserver command.
# Returns command status code.

sub execNSCmd () {
  my $function_name = "execNSCmd";
  my $self = shift;
  my $ns_cmd;
  if ( @_ > 0 ) {
    $ns_cmd = shift;
  } else {
    $self->error("$function_name: command argument missing.");
    return (1);
  }
  
  my $product = $self->getCurrentProduct();

  my $cmd = $dm_bin_dir;
  if ( $product eq 'DPM' ) {
    $ENV{DPNS_HOST} = $this_host_full;
    $cmd .= '/dpns-';
  }else {
    $ENV{LFC_HOST} = $this_host_full;
    $cmd .= '/lfc-';
  }
  $cmd .= $ns_cmd;

  $self->debug(1,"$function_name: execution command '$cmd'");

  my $errormsg='';
  my $status = $self->execCmd($cmd, \$errormsg);
  if ( $status ) {
    $self->debug(1,"$function_name: error returned by executed command ($cmd status=$status, error=$errormsg)")
  } else {
    $self->debug(2,"$function_name: command completed successfully")    
  }
  
  return($status);
}


# Function to execute an arbitrary command.
# Command must be a full path, its existence is checked  before execution and stderr is returned in
# reference provided as second argument, if present. stdout is discarded.
# Returns command status code.

sub execCmd () {
  my $function_name = "execCmd";
  my $self = shift;
  my $cmd;
  if ( @_ > 0 ) {
    $cmd = shift;
  } else {
    $self->error("$function_name: command argument missing.");
    return (1);
  }
  my $error;
  if ( @_ > 0 ) {
    $error = shift;
  }
  
  $self->debug(1,"$function_name: executing command '$cmd'");

  my @cmd_array = split /\s+/, $cmd;
  my $verb = $cmd_array[0];
  if ( ! -x $verb ) {
    $self->error("Command $verb not found");
    return(2);
  }
  
  my $errormsg = CAF::Process->new(\@cmd_array,log=>$self)->output();
  my $status = $?;

  if ( $status ) {
    $self->debug(1,"$function_name: commad $verb failed (status=$status, error=".$errormsg.")");
    if ( defined($error) ) {
      $$error = $errormsg;
    }
  } else {
    $self->debug(2,"$function_name: command $verb completed successfully")    
  }
  
  return($status);
}


# Function to define currently processed product
# Must be called before other function that need a product context
#
# Arguments :
#  product : DPM or LFC
sub defineCurrentProduct() {
  my $function_name = "defineCurrentProduct";
  my $self = shift;
  
  my $product = shift;
  unless ( $product ) {
    $self->error("$function_name: 'product' argument missing");
    return 0;
  }

  $self->{CURRENTPRODUCT} = $product;
  $self->debug(1,"$function_name: product context defined to $self->{CURRENTPRODUCT}");
}


# Function to get currently processed product
#
# Arguments :
#  none
sub getCurrentProduct() {
  my $function_name = "getCurrentProduct";
  my $self = shift;
  
  $self->debug(2,"$function_name: returning product ($self->{CURRENTPRODUCT})");
  return $self->{CURRENTPRODUCT};
}


# Function returning the host FQDN.
# localhost is handled as a special case where no domain should be added.
#
# Arguments :
#  host : a host name
sub hostFQDN () {
  my $function_name = "hostFQDN";
  my $self = shift;
  
  my $host = shift;
  unless ( $host ) {
    $self->error("$function_name: 'host' argument missing");
    return 0;
  }

  (my $host_name, my $domain) = split /\./, $host, 2;

  unless ( $domain || ($host eq "localhost") ) {
    $host = "$host.$this_host_domain";
  }

  return $host;
}


# Function to check permissions of GRIDMAPDIR and verify that host key/cert
# are present in the right place to be used by DPM or LFC
#
# Arguments :
sub checkSecurity () {
  my $function_name = "checkSecurity";
  my $self = shift;

  my $product = $self->getCurrentProduct();

  $self->info("Checking host certificate and key configuration for $product");

  my $daemon_group = $self->getDaemonGroup();
  my $daemon_user = $self->getDaemonUser();
  my $changes;

  # GRIDMAPDIR must be writable by group used by product daemons
  my $gridmapdir = $self->getGlobalOption("gridmapdir");
  unless ( $gridmapdir ) {
    $gridmapdir = $gridmapdir_def;
  }
  if ( -d $gridmapdir ) {
    $self->debug(1,"$function_name: Checking permission on $gridmapdir");
    $changes = LC::Check::status($gridmapdir,
         group => $daemon_group,
         mode => 01774
        );
    unless (defined($changes)) {
      $self->error("error setting $gridmapdir for $product");
    }
  } else {
      $self->error("$gridmapdir not found or not a directory. Check gridmap stuff is installed and properly configured");
  }

  # Put a private copy of hostcert/hostkey owned by product daemons account
  # in subdirectory of /etc/grid-security with the same name as the daemon
  # userid
  my $daemon_security_dir = $grid_security_dir."/".$daemon_user;
  my $host_hostkey = $grid_security_dir."/".$hostkey;
  my $host_hostcert = $grid_security_dir."/".$hostcert;
  my $do_keycert_config = 1;

  $self->debug(1,"$function_name: Checking existence of host key and certifiate");
  unless ( -f $host_hostkey ) {
    $self->error("Host key ($host_hostkey) not found. Check your configuration");
    $do_keycert_config = 0;
  }
  unless ( -f $host_hostcert ) {
    $self->error("Host certificate ($host_hostcert) not found. Check your configuration");
    $do_keycert_config = 0;
  }

  if ( $do_keycert_config ) {
    $self->debug(1,"$function_name: Checking existence and permission of $daemon_security_dir");
    $changes = LC::Check::directory($daemon_security_dir
         );
    unless (defined($changes)) {
      $self->error("error creating $daemon_security_dir");
      return 1;
    }
    $changes = LC::Check::status($daemon_security_dir,
         mode => 0755,
         owner => $daemon_user,
         group => $daemon_group
        );
    unless (defined($changes)) {
      $self->error("error setting security on $daemon_security_dir");
      return 1;
    }

    $self->debug(1,"$function_name: Copying host certificate ($hostcert) and key ($hostkey) to $daemon_security_dir");
    my $daemon_hostkey .= $daemon_security_dir."/".lc($product)."key.pem";
    $changes = LC::Check::file($daemon_hostkey,
             source => $host_hostkey,
             owner => $daemon_user,
             group => $daemon_group,
             mode => 0400
            );
    unless (defined($changes)) {
      $self->error("error creating $hostkey copy for $product");
    }
    my $daemon_hostcert .= $daemon_security_dir."/".lc($product)."cert.pem";
    $changes = LC::Check::file($daemon_hostcert,
             source => $host_hostcert,
             owner => $daemon_user,
             group => $daemon_group,
             mode => 0644
            );
    unless (defined($changes)) {
      $self->error("error creating $hostcert copy for $product");
    }
  }

}


# Function to return a global option value from configuration
# Arguments :
#  option : option name
sub getGlobalOption () {
  my $function_name = "getGlobalOption";
  my $self = shift;

  my $option = shift;
  unless ( $option ) {
    $self->error("$function_name: 'option' argument missing");
    return 0;
  }

  my $product = $self->getCurrentProduct();

  if ( exists($dpmlfc_config->{options}->{lc($product)}->{$option}) ) {
    my $value = $dpmlfc_config->{options}->{lc($product)}->{$option};
    $self->debug(2,"$function_name: Global option '$option' found : ".$value);
    return $value;
  } else {
    $self->debug(2,"$function_name: Global option '$option' not found : ");    
    return undef;
  }


}


# Function to retrieve a DB option value from configuration
# Arguments :
#  option : option name
sub getDbOption () {
  my $function_name = "getDbOption";
  my $self = shift;

  my $option = shift;
  unless ( $option ) {
    $self->error("$function_name: 'option' argument missing");
    return 0;
  }

  my $product = $self->getCurrentProduct();

  if ( exists($dpmlfc_config->{options}->{lc($product)}->{db}->{$option}) ) {
    return $dpmlfc_config->{options}->{lc($product)}->{db}->{$option};
  } else {
    $self->debug(1,"DB option '$option' not found for product $product");
    return undef;
  }

}


# Function returning the userid used by product daemons
# Default : as specified in %users_def
#
# Arguments : 
#  none
sub getDaemonUser () {
  my $function_name = "getDaemonUser";
  my $self = shift;

  my $daemon_user = $config_options->{"user"};
  unless ( $daemon_user ) {
    $daemon_user = $users_def{$self->getCurrentProduct()};
    $self->debug(1,"$function_name: daemon user set to default value ($daemon_user)");
  }
 
  return $daemon_user;
}


# Function returning the group used by product daemons
# Default : same as userid
#
# Arguments : 
#  none
sub getDaemonGroup () {
  my $function_name = "getDaemonGroup";
  my $self = shift;

  my $daemon_group = $config_options->{"group"};
  unless ( $daemon_group ) {
    $daemon_group = $self->getDaemonUser();
    $self->debug(1,"$function_name: daemon group set to default value ($daemon_group)");
  }

  return $daemon_group;
}


# Function returning the server to use to manage databases.
# Returns the db server or localhost if db server is the current node
# (to maximize chance to get success on an unconfigured server)
#
# Arguments : 
#  none
sub getDbAdminServer () {
  my $function_name = "getDbAdminServer";
  my $self = shift;

  my $db_admin_server = $config_options->{"dbserver"};
  unless ( $db_admin_server ) {
    $self->error("Database server not defined");
  }
  if ( $db_admin_server eq $this_host_full ) {
    $self->debug(2,"$function_name: database server is current host. Changing management server to localhost");
    $db_admin_server = "localhost";
  } else {
    $self->debug(2,"$function_name: database management server is $db_admin_server");
  }
  return $db_admin_server;
}


# Function to create the DB configuration file
#
# Arguments : 
sub createDbConfigFile () {
  my $function_name = "createDbConfigFile";
  my $self = shift;

  my $product = $self->getCurrentProduct();
  $self->debug(1,"$function_name: Creating database configuration file for $product");

  unless ( exists($dpmlfc_config->{options}->{lc($product)}->{db}) ) {
    $self->warn("Cannot configure DB connection : configuration missing in profile");
    return 1;
  }

  my $do_db_config = 1;

  # Owner of the DB configuration file
  my $daemon_user = $self->getDaemonUser();
  my $daemon_group = $self->getDaemonGroup();

  my $db_user = $self->getDbOption("user");
  unless ( $db_user ) {
    $self->warn("Cannot configure DB connection : DB username missing");
    return 1; 
  }
  $config_options->{"dbuser"} = $db_user;

  my $db_pwd = $self->getDbOption("password");
  unless ( $db_pwd ) {
    $self->warn("Cannot configure DB connection : DB password missing");
    return 1;
  }
  $config_options->{"dbpwd"} = $db_pwd;

  my $db_server = $self->getDbOption("server");
  unless ( $db_server ) {
    $db_server = $this_host_full;
    $self->debug(1,"$function_name: DB server not configured. Using $db_server");
  }
  $db_server = $self->hostFQDN($db_server);
  if ( exists($db_servers{$db_server}) ) {
    unless ($db_servers{$db_server} eq $product) {
      $self->error("DPM and LFC cannot run on the same server. Skipping database configuration.");
      return 1;
    }
  } else {
    $db_servers{$db_server} = $product;
  }
  $config_options->{"dbserver"} = $db_server;


  # info_user is the MySQL user used by GIP to collect DPM statistics.
  # Configure only if GIP is configured on the machine.
  my $db_info_user;
  my $db_info_pwd;
  my $db_info_file;
  if ( $gip_user ) {
    $db_info_user = $self->getDbOption("infoUser");
    if ( $db_info_user ) {
      $config_options->{"dbinfouser"} = $db_info_user;
      $db_info_pwd = $self->getDbOption("infoPwd");
      if ( $db_info_pwd ) {
        $config_options->{"dbinfopwd"} = $db_info_pwd;
      } else {
        $self->warn("Cannot configure DB for info user : DB password missing.");
        return 1;
      }
      $db_info_file= $self->getDbOption("infoFile");
      unless ( $db_info_file ) {
        $db_info_file = $product . "INFO";
        $self->info("DB info connection file not configured. Set to default ($db_info_file)");
      }
    } else {
      $self->debug(1,"$function_name: DB infoUser not defined, DB configuration for GIP ignored.");
    }
  } else {
    $self->debug(1,"GIP no configured on this node. Skipping $product DB configuration for GIP.");
  }

  # Update DB connection configuration file for main user if content has changed
  my $config_contents = "$db_user/$db_pwd\@$db_server";
  my $config_fh = CAF::FileWriter->new($config_options->{"dbconfigfile"}.$config_prod_ext,
                                       backup => $config_bck_ext,
                                       contents => $config_contents,
                                       owner => $daemon_user,
                                       group => $daemon_group,
                                       mode => oct($config_options->{"dbconfigmode"}),
                                       log => $self,
                                      );
  print $config_fh "$db_user/$db_pwd\@$db_server\n";
  my $changes = $config_fh->close();


  # Update DB connection configuration file for information user if content has changed
  # No service needs to be restarted.
  if ( $db_info_user ) {
    my $info_fh = CAF::FileWriter->new($db_info_file.$config_prod_ext,
                                       backup => $config_bck_ext,
                                       contents => $config_contents,
                                       owner => $gip_user,
                                       group => $daemon_group,
                                       mode => oct($config_options->{"dbconfigmode"}),
                                       log => $self,
                                      );
    print $info_fh "$db_info_user/$db_info_pwd\@$db_server\n";
    my $info_changes = $info_fh->close();
    if ( $info_changes < 0 ) {
      $self->error("Error configuring connection file for info user. $product publication into BDII may not work.");
    }
  } else {
    $self->debug(1,"GIP no configured on this node. Skipping $product DB configuration for GIP.");
  }


  # Return a negative status in case of success with changes requiring restart
  # of dependent services
  return ( - $changes);

}


# Function returning the list of services associated with a role, if the role
# is enabled on current node. Services list is returned as an array.
# If the role is not enabled on current node or in case of error (no
# such role or role with no associated service), return an empty array.
#
# Arguments :
#  role : role the services need to be restarted
sub getRoleServices () {
  my $function_name = "getRoleServices";
  my $self = shift;

  my $role = shift;
  unless ( $role ) {
    $self->error("$function_name: 'role' argument missing");
    return 0;
  }

  $self->debug(1,"$function_name: retrieving list of services associated with role $role");

  my @services;

  my $service_list = $services{$role};
  unless ( $service_list ) {
    $self->debug(1,"$function_name: no services associated with role '$role'");
    return @services;
  }

  # If list is a role list instead of a service list (role:...), look for actual service
  # name. No check for potential loop implemented... take care of configuration.
  # Duplicates are removed.

  (my $role_flag, my $roles) = split /:/, $service_list;
  if ( ($role_flag ne "role") && $roles ) {
    $self->error("$function_name: invalid flag ($role_flag) in list of services associated with role $role");
  }

  if ( $roles ) {
    my %enabled_services;
    my @roles = split /\s*,\s*/, $roles;
    for my $role (@roles) {
      if ( $self->hostHasRoles($role) ) {
        if ( exists($services{$role}) ) {
          my @role_services = split /\s*,\s*/, $services{$role};
          for my $service (@role_services) {
            $enabled_services{$service}="";
          }
        } else {
          $self->error("$function_name: no services associated with role '$role' (internal error)");
        }
      } else {
        $self->debug(1,"$function_name: host doesn't have role $role");
      }
    }
    @services = keys %enabled_services;
  } else {
    if ( $self->hostHasRoles($role) ) {
      @services = split /\s*,\s*/, $service_list;
    } else {
      $self->debug(1,"$function_name: host doesn't have role $role");
    }
  }

  return @services;
}


# Function to add a service in the list of services needed to be restarted.
# Services can be a comma separated list.
# Services are added to the list only if the current host has the role
# passed as argument.
# It is valid to pass a role with no associated services (nothing done).
#
# Arguments :
#  roles : roles the associated services need to be restarted (comma separated list)
sub serviceRestartNeeded () {
  my $function_name = "serviceRestartNeeded";
  my $self = shift;

  my $roles = shift;
  unless ( $roles ) {
    $self->error("$function_name: 'roles' argument missing");
    return 0;
  }

  my $list;
  unless ( $list = $self->getServiceRestartList() ) {
    $self->debug(1,"$function_name: Creating list of service needed to be restarted");
    $self->{SERVICERESTARTLIST} = {};
    $list = $self->getServiceRestartList();
  }

  my @roles = split /\s*,\s*/, $roles;
  for my $role (@roles) {
    for my $service ($dpmlfc_config->($role)->{hostlist}) {
      unless ( exists(${$list}{$service}) ) {
        $self->debug(1,"$function_name: adding '$service' to the list of service needed to be restarted");
        ${$list}{$service} = "";
      }
    }
  }

  $self->debug(2,"$function_name: restart list = '".join(" ",keys(%{$list}))."'");
}


# Return list of services needed to be restarted
sub getServiceRestartList () {
  my $function_name = "getServiceRestartList";
  my $self = shift;

  if ( defined($self->{SERVICERESTARTLIST}) ) {
    $self->debug(2,"$function_name: restart list = ".join(" ",keys(%{$self->{SERVICERESTARTLIST}})));
    return $self->{SERVICERESTARTLIST};
  } else {
    $self->debug(2,"$function_name: list doesn't exist");
    return undef
  }

}


# Function returning name of hash handling the list of enabled services for to the current product
#
# Arguments :
#  none
sub getEnabledServiceListName () {
  my $function_name = "getEnabledServiceListName";
  my $self = shift;

  my $product = $self->getCurrentProduct();

  return "SERVICEENABLEDLIST".$product;
}


# Enable a service to be started during system startup
#
# Arguments :
#  service : name of the service
sub enableService () {
  my $function_name = "enableService";
  my $self = shift;

  my $service = shift;
  unless ( $service ) {
    $self->error("$function_name: 'service' argument missing");
    return 0;
  }

  $self->debug(1,"$function_name: checking if service $service is enabled");

  unless ( -f "/etc/rc.d/init.d/$service" ) {
    $self->error("Startup script not found for service $service");
    return 1;
  }

  CAF::Process->new([$chkconfig, $service],log=>$self)->run();
  if ( $? ) {
    # No need to do chkconfig --add first, done by default
    $self->info("Enabling service $service at startup");
    CAF::Process->new([$chkconfig, $service, "on"],log=>$self)->run();
    if ( $? ) {
      $self->error("Failed to enable service $service");
    }
  } else {
    $self->debug(2,"$function_name: $service already enabled");
  }

  my $enabled_service_list_name = $self->getEnabledServiceListName();
  unless ( defined($self->{$enabled_service_list_name}) ) {
      $self->{$enabled_service_list_name} = {};
  }
  $self->{$enabled_service_list_name}->{$service} = 1;     # Value is useless

}


# Generate an init script to control (start/stop/restart) all enabled services.

sub buildEnabledServiceInitScript () {
  my $function_name = "buildEnabledServiceInitScript";
  my $self = shift;

  my $init_script_name = '/etc/init.d/'.lc($self->getCurrentProduct()).'-all-daemons';
  my $enabled_service_list_name = $self->getEnabledServiceListName();
  my $contents;

  # The list should not be defined if it is empty...
  if ( $self->{$enabled_service_list_name} ) {
    $self->info("Checking init script used to control all ".$self->getCurrentProduct()." enabled services (".$init_script_name.")...");
    $contents = "#!/bin/sh\n\n";
    for my $service (keys(%{$self->{$enabled_service_list_name}})) {
      if ( $self->{$enabled_service_list_name}->{$service} ) {
        $contents .= "/etc/init.d/".$service." \$*\n";
      }
    }
    
    my $fh = CAF::FileWriter->new($init_script_name,
                                  contents => $contents,
                                  owner => 'root',
                                  group => 'root',
                                  mode => 0755,
                                  log => $self,
                                 );
    if ( $fh->close() < 0 ) {
      $self->warn("Error creating init script to control all ".$self->getCurrentProduct()." services ($init_script_name)");
    }
  } else {
    $self->debug(1,"$function_name: no service enabled for ".$self->getCurrentProduct().' ('.$init_script_name.')');
  }
}


# Restart services needed to be restarted
# Returns 0 if all services have been restarted successfully, else
# the number of services which failed to restart.

sub restartServices () {
  my $function_name = "RestartServices";
  my $self = shift;
  my $global_status = 0;
  
  $self->debug(1,"$function_name: restarting services affected by configuration changes");

  # Need to do stop+start as sometimes dpm daemon doesn't restart properly with
  # 'restart'. Try to restart even if stop failed (can be just the daemon is 
  # already stopped)
  if ( my $list = $self->getServiceRestartList() ) {
    $self->debug(1,"$function_name: list of services to restart : ".join(" ",keys(%{$list})));
    for my $service (keys %{$list}) {
      $self->info("Restarting service $service");
      CAF::Process->new([$servicecmd, $service, "stop"],log=>$self)->run();
      if ( $? ) {
        # Service can be stopped, don't consider failure to stop as an error
        $self->warn("\tFailed to stop $service");
      }
      sleep 5;    # Give time to the daemon to shut down
      my $attempt = 10;
      my $status;
      my $command = CAF::Process->new([$servicecmd, $service, "start"],log=>$self);
      $command->run();
      $status = $?;
      while ( $attempt && $status ) {
        $self->debug(1,"$function_name: $service startup failed (probably not shutdown yet). Retrying ($attempt attempts remaining)");
        sleep 5;
        $attempt--;
        $command->run();
        $status = $?;
      }
      if ( $status ) {
        $global_status++;
        $self->error("\tFailed to start $service");
      } else {
        $self->info("Service $service restarted successfully");
      }
    }
  }

  return($global_status);
}


# This function returns true if the current machine is listed in the hosts list
# for one of the roles passed as argument.
#
# Arguments
#       roles : comma separated roles list. 
sub hostHasRoles () {
  my $function_name = "hostHasRoles";
  my $self = shift;

  my $roles = shift;
  unless ( $roles ) {
    $self->error("$function_name: 'roles' argument missing");
    return 0;
  }

  my $role_found = 0;    # Assume host doesn't have any role
  my @roles = split /\s*,\s*/, $roles;

  for my $role (@roles) {
    $self->debug(2,"$function_name: checking for role >>>$role<<< on host >>>$this_host_full<<<");
    if ( exists($config_options->{$role}) ) {
      if ( grep(/^$this_host_full$/,@{$config_options->{$role}->{hostlist}}) ) {
        $self->debug(1,"$function_name: role $role found on host $this_host_full");
        $role_found = 1;
        last;        
      } else {
        $self->debug(1,"$function_name: role $role NOT found on host $this_host_full");    
      }
    } else {
      $self->error("$function_name: role $role not defined in configuration");
    }
  }
  return $role_found;
}


# This function returns a string containing hosts list for a role (sorted)
#
# Arguments
#       role : role for which the hosts list must be normalized
sub getHostsList () {
  my $function_name = "getHostsList";
  my $self = shift;

  my $role = shift;
  unless ( $role ) {
    $self->error("$function_name: 'role' argument missing");
    return 1;
  }

  my $hostlist="";
  if ( exists($config_options->{$role}) ) {
    $hostlist = join(" ",@{$config_options->{$role}->{hostlist}});
  } else {
    $self->error("$function_name: role $role not defined in configuration");
  }

  $self->debug(1,"Hosts list for role ".uc($role)." : >>$hostlist<<");
  return $hostlist;
}


# This function returns host config.
#
# Arguments
#       role : role for which the hosts list must be normalized
#       host : host for which configuration must be returned
sub getHostConfig () {
  my $function_name = "getHostConfig";
  my $self = shift;

  my $role = shift;
  unless ( $role ) {
    $self->error("$function_name: 'role' argument missing");
    return 1;
  }
  my $host = shift;
  unless ( $host ) {
    $self->error("$function_name: 'host' argument missing");
    return 1;
  }

  if ( exists($dpmlfc_config->{$role}) && exists($dpmlfc_config->{$role}->{$host}) ) {
    $self->debug(3,"$function_name: keys in $role options: ".join(",",keys(%{$dpmlfc_config->{$role}->{$host}})));
    return $dpmlfc_config->{$role}->{$host};
  } else {
    $self->verbose("$function_name: host '$host' not found in role '$role' options: returning an empty option set");
    return {};
  }
}


# This function formats an attribute value based on the value format specified.
#
# Arguments :
#        attr_value : attribue value
#        line_fmt : line format (see LINE_FORMAT_xxx constants)
#        value_fmt : value format (see LINE_VALUE_xxx constants)
sub formatAttributeValue () {
  my $function_name = "formatAttributeValue";
  my $self = shift;

  my $attr_value = shift;
  unless ( defined($attr_value) ) {
    $self->error("$function_name: 'attr_value' argument missing");
    return 1;
  }
  my $line_fmt = shift;
  unless ( defined($line_fmt) ) {
    $self->error("$function_name: 'list_fmt' argument missing");
    return 1;
  }
  my $value_fmt = shift;
  unless ( defined($value_fmt) ) {
    $self->error("$function_name: 'value_fmt' argument missing");
    return 1;
  }

  $self->debug(2,"$function_name: formatting attribute value >>>$attr_value<<< (line fmt=$line_fmt, value fmt=$value_fmt)");

  my $formatted_value;
  if ( $value_fmt == LINE_VALUE_HOST_LIST ) {    
    # Duplicates may exist as result of a join. Checkt it.
    my @hosts = split /\s+/, $attr_value;
    my %hosts;
    for my $host (@hosts) {
      unless ( exists($hosts{$host}) ) {
        $hosts{$host} = "";
      }
    }  
    my $formatted_value="";
    for my $host (sort keys %hosts) {
      $formatted_value .= "$host ";
    }
    # Some config files are sensitive to extra spaces : suppress trailing spaces
    $formatted_value =~ s/\s+$//;
    $self->debug(1,"Formatted hosts list : >>$formatted_value<<");

  } elsif ( $value_fmt == LINE_VALUE_BOOLEAN ) {
    if ( $attr_value ) {
      $formatted_value = '"yes"';
    } else {
      $formatted_value = '"no"';
    }

  } elsif ( $value_fmt == LINE_VALUE_INSTANCE_PARAMS ) {
    # Instance parameters are described in a nlist
    if ( exists($attr_value->{logFile}) ) {
      $formatted_value .= " -l $attr_value->{logFile}";
    }
    if ( exists($attr_value->{configFile}) ) {
      $formatted_value .= " -c $attr_value->{configFile}";
    }
    if ( exists($attr_value->{logKeep}) ) {
      $formatted_value .= " -k $attr_value->{logKeep}";
    }
    
  } elsif ( $value_fmt == LINE_VALUE_ARRAY ) {
    $formatted_value = join " ", @$attr_value;

  } elsif ( $value_fmt == LINE_VALUE_HASH_KEYS ) {
    $formatted_value = join " ", keys(%$attr_value);
    
  } elsif ( ($value_fmt == LINE_VALUE_AS_IS) || ($value_fmt == LINE_VALUE_STRING_HASH) ) {
    $formatted_value = $attr_value;
    
  } else {
    $self->error("$function_name: invalid value format ($value_fmt) (internal error)")    
  }

  # Quote value if necessary
  if ( ($line_fmt == LINE_FORMAT_PARAM) || ($line_fmt == LINE_FORMAT_ENVVAR) ) {
    if ( $formatted_value =~ /\s+/ ) {
      $self->debug(2,"$function_name: quoting value '$formatted_value'");
      $formatted_value = '"' . $formatted_value . '"';
    }
  }
  
  $self->debug(2,"$function_name: formatted value >>>$formatted_value<<<");
  return $formatted_value;
}


# This function formats a configuration line using keyword and value,
# according to the line format requested. Values containing spaces are
# quoted if the line format is not LINE_FORMAT_XRDCFG.
#
# Arguments :
#        keyword : line keyword
#        value : keyword value (can be empty)
#        line_fmt : line format (see LINE_FORMAT_xxx constants)
sub formatConfigLine () {
  my $function_name = "formatConfigLine";
  my $self = shift;

  my $keyword = shift;
  unless ( $keyword ) {
    $self->error("$function_name: 'keyword' argument missing");
    return 1;
  }
  my $value = shift;
  unless ( defined($value) ) {
    $self->error("$function_name: 'value' argument missing");
    return 1;
  }
  my $line_fmt = shift;
  unless ( defined($line_fmt) ) {
    $self->error("$function_name: 'line_fmt' argument missing");
    return 1;
  }

  my $config_line = "";

  if ( $line_fmt == LINE_FORMAT_PARAM ) {
    $config_line = "$keyword=$value";
  } elsif ( $line_fmt == LINE_FORMAT_ENVVAR ) {
    $config_line = "export $keyword=$value";
  } elsif ( $line_fmt == LINE_FORMAT_XRDCFG_SETENV ) {
    $config_line = "setenv $keyword = $value";
  } elsif ( $line_fmt == LINE_FORMAT_XRDCFG_SET ) {
    $config_line = "set $keyword = $value";
  } elsif ( $line_fmt == LINE_FORMAT_XRDCFG ) {
    $config_line = $keyword;
    $config_line .= " $value" if $value;
    # In trust (shift.conf) format, there should be only one blank between
    # tokens and no trailing spaces.
    $config_line =~ s/\s\s+/ /g;
    $config_line =~ s/\s+$//;
  } else {
    $self->error("$function_name: invalid line format ($line_fmt). Internal inconsistency.");
  }

  $self->debug(2,"$function_name: Configuration line : >>$config_line<<");
  return $config_line;
}


# This function builds a pattern that will match an existing configuration line for
# the configuration parameter specified. The pattern built takes into account the line format.
# Every whitespace in the pattern (configuration parameter) are replaced by \s+.
# If the line format is LINE_FORMAT_XRDCFG, no whitespace is
# imposed at the end of the pattern, as these format can be used to write a configuration
# directive as a keyword with no value.
#
# Arguments :
#   config_param: parameter to update
#   line_fmt: line format (see LINE_FORMAT_xxx constants)
#   config_value: when defined, make it part of the pattern (used when multiple lines
#                 with the same keyword are allowed)
sub buildLinePattern () {
  my $function_name = "buildLinePattern";
  my $self = shift;

  my $config_param = shift;
  unless ( $config_param ) {
    $self->error("$function_name: 'config_param' argument missing");
    return undef;
  }
  my $line_fmt = shift;
  unless ( defined($line_fmt) ) {
    $self->error("$function_name: 'line_fmt' argument missing");
    return undef;
  }
  my $config_value = shift;
  if ( $config_value ) {
    $self->debug(2,"$function_name: configuration value '$config_value' will be added to the pattern");
    $config_value =~ s/\s+/\\s+/g;
    $config_value =~ s/\-/\\-/g;
    $config_value =~ s/\./\\./g;
    $config_value =~ s/\*/\\*/g;
    $config_value =~ s/\[/\\[/g;
    $config_value =~ s/\]/\\]/g;
    $config_value =~ s/\(/[(]/g;
    $config_value =~ s/\)/\\)/g;
    $config_value =~ s/\$/\\\$/g;
    $config_value =~ s/\^/\\^/g;
  } else {
    $config_value = "";
  }

  $config_param =~ s/\s+/\\s+/g;
  my $config_param_pattern;
  if ( $line_fmt == LINE_FORMAT_PARAM ) {
    $config_param_pattern = "#?\\s*$config_param=".$config_value;
  } elsif ( $line_fmt == LINE_FORMAT_ENVVAR ) {
    $config_param_pattern = "#?\\s*export $config_param=".$config_value;
  } elsif ( $line_fmt == LINE_FORMAT_XRDCFG_SETENV ) {
    $config_param_pattern = "#?\\s*setenv\\s+$config_param\\s*=\\s*".$config_value;
  } elsif ( $line_fmt == LINE_FORMAT_XRDCFG_SET ) {
    $config_param_pattern = "#?\\s*set\\s+$config_param\\s*=\\s*".$config_value;
  } elsif ( $line_fmt == LINE_FORMAT_XRDCFG ) {
    $config_param_pattern = "#?\\s*$config_param";
    # Avoid adding a withespace requirement if there is no config_value
    if ( $config_value ne "" ) {
      $config_param_pattern .= "\\s+" . $config_value;
    }
  } else {
    $self->error("$function_name: invalid line format ($line_fmt). Internal inconsistency.");
    return undef;
  }

  return $config_param_pattern
}


# This function comments out a configuration line matching the configuration parameter.
# Match operation takes into account the line format.
#
# Arguments :
#        fh : a FileEditor object
#        config_param: parameter to update
#        line_fmt : line format (see LINE_FORMAT_xxx constants)
sub removeConfigLine () {
  my $function_name = "removeConfigLine";
  my $self = shift;

  my $fh = shift;
  unless ( $fh ) {
    $self->error("$function_name: 'fh' argument missing");
    return 1;
  }
  my $config_param = shift;
  unless ( $config_param ) {
    $self->error("$function_name: 'config_param' argument missing");
    return 1;
  }
  my $line_fmt = shift;
  unless ( defined($line_fmt) ) {
    $self->error("$function_name: 'line_fmt' argument missing");
    return 1;
  }

  # Build a pattern to look for.
  my $config_param_pattern = $self->buildLinePattern($config_param,$line_fmt);

  $self->debug(1,"$function_name: commenting out lines matching pattern >>>".$config_param_pattern."<<<");
  # All matching lines must be commented out, except if they are already commented out.
  # The code used is a customized version of FileEditor::replace() that lacks backreferences.
  my @lns;
  my $line_count = 0;
  seek($fh, 0, SEEK_SET);
  while (my $l = <$fh>) {
    if ($l =~ qr/^$config_param_pattern/ && $l !~ qr/^\s*#/) {
        $self->debug(2,"$function_name: commenting out matching line >>>".$l."<<<");
        $line_count++;
        push (@lns, '#'.$l);
    } else {
        push (@lns, $l);
    }
  }
  if ( $line_count == 0 ) {
    $self->debug(1, "$function_name: No line found matching the pattern");
  } else {
    $self->debug(1, "$function_name: $line_count lines commented out");
  }
  $fh->set_contents (join("", @lns));
 
}


# This function do the actual update of a configuration line after doing the final
# line formatting based on the line format.
#
# Arguments :
#        fh : a FileEditor object
#        config_param: parameter to update
#        config_value : parameter value (can be empty)
#        line_fmt : line format (see LINE_FORMAT_xxx constants)
#        multiple : if true, multiple lines with the same keyword can exist (D: false)
sub updateConfigLine () {
  my $function_name = "updateConfigLine";
  my $self = shift;

  my $fh = shift;
  unless ( $fh ) {
    $self->error("$function_name: 'fh' argument missing");
    return 1;
  }
  my $config_param = shift;
  unless ( $config_param ) {
    $self->error("$function_name: 'config_param' argument missing");
    return 1;
  }
  my $config_value = shift;
  unless ( defined($config_value) ) {
    $self->error("$function_name: 'config_value' argument missing");
    return 1;
  }
  my $line_fmt = shift;
  unless ( defined($line_fmt) ) {
    $self->error("$function_name: 'line_fmt' argument missing");
    return 1;
  }
  my $multiple = shift;
  unless ( defined($multiple) ) {
    $multiple = 0;
  }

  my $newline;
  my $config_param_pattern;
  $newline = $self->formatConfigLine($config_param,$config_value,$line_fmt);

  # Build a pattern to look for.
  if ( $multiple ) {
    $self->debug(2,"$function_name: 'multiple' flag enabled");
    $config_param_pattern = $self->buildLinePattern($config_param,$line_fmt,$config_value);    
  } else {
    $config_param_pattern = $self->buildLinePattern($config_param,$line_fmt);
  }
  if ( ($line_fmt == LINE_FORMAT_XRDCFG) && !$multiple ) {
    if ( $config_value ) {
      $config_param_pattern .= "\\s+";    # If the value is defined in these formats, impose a whitespace at the end
    }
  }

  # Update the matching configuration lines
  if ( $newline ) {
    my $comment = "";
    if ( ($line_fmt == LINE_FORMAT_PARAM) || ($line_fmt == LINE_FORMAT_ENVVAR) ) {
      $comment = LINE_QUATTOR_COMMENT;
    }
    $self->debug(1,"$function_name: checking expected configuration line ($newline) with pattern >>>".$config_param_pattern."<<<");
    $fh->add_or_replace_lines(qr/^$config_param_pattern/,
                              qr/^$newline$/,
                              $newline.$comment."\n",
                              ENDING_OF_FILE,
                             );      
  }
}


# Update configuration file content,  applying configuration rules.
#
# Arguments :
#       file_name: name of the file to update
#       config_rules: config rules corresponding to the file to build
#       config_options: configuration parameters used to build actual configuration
#       options: a hash setting options to modify the behaviour of this function
#
# Supported entries for options hash:
#       always_rules_only: if true, apply only rules with ALWAYS condition (D: false)
#       remove_if_undef: if true, remove maatching configuration line is rule condition is not met (D: false)

sub updateConfigFile () {
  my $function_name = "updateConfigFile";
  my $self = shift;

  my $file_name = shift;
  unless ( $file_name ) {
    $self->error("$function_name: 'file_name' argument missing");
    return 1;
  }
  my $config_rules = shift;
  unless ( $config_rules ) {
    $self->error("$function_name: 'config_rules' argument missing");
    return 1;
  }
  my $config_options = shift;
  unless ( $config_options ) {
    $self->error("$function_name: 'config_options' argument missing");
    return 1;
  }
  my $parser_options = shift;
  unless ( defined($parser_options) ) {
    $self->debug(2,"$function_name: 'parser_options' undefined");
    $parser_options = {};
  }
  if ( defined($parser_options->{always_rules_only}) ) {
    $self->debug(1,"$function_name: 'always_rules_only' option set to ".$parser_options->{always_rules_only});
  } else {
    $self->debug(1,"$function_name: 'always_rules_only' option not defined: assuming ".LINE_OPT_DEF_ALWAYS_RULES_ONLY);
    $parser_options->{always_rules_only} = LINE_OPT_DEF_ALWAYS_RULES_ONLY;
  }
  if ( defined($parser_options->{remove_if_undef}) ) {
    $self->debug(1,"$function_name: 'remove_if_undef' option set to ".$parser_options->{remove_if_undef});
  } else {
    $self->debug(1,"$function_name: 'remove_if_undef' option not defined: assuming ".LINE_OPT_DEF_REMOVE_IF_UNDEF);
    $parser_options->{remove_if_undef} = LINE_OPT_DEF_REMOVE_IF_UNDEF;
  }

  my $fh = CAF::FileEditor->new($file_name,
                                backup => BACKUP_FILE_EXT,
                                log => $self);
  seek($fh, 0, SEEK_SET);

  # Check that config file has an appropriate header
  my $intro_pattern = "# This file is managed by Quattor";
  my $intro = "# This file is managed by Quattor - DO NOT EDIT lines generated by Quattor";
  $fh->add_or_replace_lines(qr/^$intro_pattern/,
                            qr/^$intro$/,
                            $intro."\n#\n",
                            BEGINNING_OF_FILE,
                           );
  
  # Loop over all config rule entries.
  # Config rules are stored in a hash whose key is the variable to write
  # and whose value is the rule itself.
  # If the variable name start with a '-', this means that the matching configuration
  # line must be commented out unconditionally.
  # Each rule format is '[condition->]attribute:option_set[,option_set,...];line_fmt' where
  #     condition: either a role that must be enabled or ALWAYS if the rule must be applied 
  #                when 'always_rules_only' is true. A role is enabled if 'role_enabled' is
  #                true in the corresponding option set.
  #     option_set and attribute: attribute in option set that must be substituted
  #     line_fmt: the format to use when building the line
  # An empty rule is valid and means that the keyword part must be
  # written as is, using the line_fmt specified.
  
  my $rule_id = 0;
  foreach my $keyword (sort keys %{$config_rules}) {
    my $rule = $config_rules->{$keyword};
    $rule_id++;

    # Check if the keyword is prefixed by a '-': in this case the corresponding line must
    # be commented out if it present
    my $comment_line = 0;
    if ( $keyword =~ /^-/ ) {
      $keyword =~ s/^-//;
      $comment_line = 1;
    }

    # Split different elements of the rule
    ($rule, my $line_fmt, my $value_fmt) = split /;/, $rule;
    unless ( $line_fmt ) {
      $line_fmt = LINE_FORMAT_DEFAULT;
    }
    my $value_opt;
    if ( $value_fmt ) {
      ($value_fmt, $value_opt) = split /:/, $value_fmt;
    }else {
      $value_fmt = LINE_VALUE_AS_IS;
    }
    unless ( defined($value_opt) ) {
      $value_opt = LINE_VALUE_OPT_NONE;      
    }

    (my $condition, my $tmp) = split /->/, $rule;
    if ( $tmp ) {
      $rule = $tmp;
    } else {
      $condition = "";
    }
    $self->debug(1,"$function_name: processing rule ".$rule_id."(variable=>>>".$keyword.
                      "<<<, comment_line=".$comment_line.", condition=>>>".$condition."<<<, rule=>>>".$rule."<<<, fmt=".$line_fmt.")");

    # Check if only rules with ALWAYS conditions must be applied 
    if ( $parser_options->{always_rules_only} ) {
      if ( $condition eq "ALWAYS" ) {
        $condition = '';
      } else {
        $self->debug(1,"$function_name: rule ignored (ALWAYS condition not set)");
        next;
      }
    }

    # If the variable name was "negated", remove (comment out) configuration line if present and enabled
    if ( $comment_line ) {
      $self->debug(1,"$function_name: keywork '$keyword' negated, removing configuration line");
      $self->removeConfigLine($fh,$keyword,$line_fmt);
      next;
    }

    # Check if rule condition is met
    unless ( $condition eq "" ) {
      $self->debug(1,"$function_name: checking condition >>>$condition<<<");

      # Condition may be negated if it starts with a !
      my $negate = 0;
      if ( $condition =~ /^!/ ) {
        $negate = 1;
        $condition =~ s/^!//;
      }
      my ($cond_attribute,$cond_option_set) = split /:/, $condition;
      unless ( $cond_option_set ) {
        $cond_option_set = $cond_attribute;
        $cond_attribute = "";
      }
      $self->debug(2,"$function_name: condition option set = '$cond_option_set', ".
                         "condition attribute = '$cond_attribute', negate=$negate");
      my $cond_satisfied = 1;
      if ( $cond_attribute ) {
        # Due to an exists() flaw, testing directly exists($config_options->{$cond_option_set}->{$cond_attribute}) will spring
        # into existence $config_options->{$cond_option_set} if it doesn't exist.
        if ( $negate ) {
          $cond_satisfied = 0 if exists($config_options->{$cond_option_set}) && 
                                 exists($config_options->{$cond_option_set}->{$cond_attribute});          
        } else {          
          $cond_satisfied = 0 unless exists($config_options->{$cond_option_set}) &&
                                     exists($config_options->{$cond_option_set}->{$cond_attribute});
        }
      } elsif ( $cond_option_set ) {
        if ( $negate ) {
          $cond_satisfied = 0 if exists($config_options->{$cond_option_set});
        } else {         
          $cond_satisfied = 0 unless exists($config_options->{$cond_option_set});
        }
      }
      # Remove (comment out) configuration line if present and enabled
      # and if option remove_if_undef is set
      unless ( $cond_satisfied || !$parser_options->{remove_if_undef} ) {
        $self->debug(1,"$function_name: condition met but negated, removing configuration line");
        $self->removeConfigLine($fh,$keyword,$line_fmt);
        next;
      }
    }

    my @option_sets;
    (my $attribute, my $option_sets_str) = split /:/, $rule;
    if ( $option_sets_str ) {
      @option_sets = split /\s*,\s*/, $option_sets_str;
    }

    # Build the value to be substitued for each option set specified.
    # option_set=GLOBAL is a special case indicating a global option instead of an
    # attribute in a specific option set.
    my $config_value = "";
    my $attribute_present = 1;
    my $config_updated = 0;
    if ( $attribute ) {
      for my $option_set (@option_sets) {
        my $attr_value;
        if ( $option_set eq "GLOBAL" ) {
          if ( exists($config_options->{$attribute}) ) {
            $attr_value = $config_options->{$attribute};
          } else {
            $self->debug(1,"$function_name: attribute '$attribute' not found in global option set");
            $attribute_present = 0;
          }
        } else {
          # Due to an exists() flaw, testing directly exists($config_options->{$cond_option_set}->{$cond_attribute}) will spring
          # into existence $config_options->{$cond_option_set} if it doesn't exist.
          if ( exists($config_options->{$option_set}) && exists($config_options->{$option_set}->{$attribute}) ) {
            $attr_value = $config_options->{$option_set}->{$attribute};
          } else {
            $self->debug(1,"$function_name: attribute '$attribute' not found in option set '$option_set'");
            $attribute_present = 0;
          } 
        }

        # If attribute is not defined in the present configuration, check if there is a matching
        # line in the config file for the keyword and comment it out. This requires option 
        # remove_if_undef to be set.
        # Note that this will never match instance parameters and will not remove entries
        # no longer part of the configuration in a still existing LINE_VALUE_ARRAY or
        # LINE_VALUE_STRING_HASH.
        unless ( $attribute_present ) {
          if ( $parser_options->{remove_if_undef} ) {
            $self->debug(1,"$function_name: attribute '$attribute' undefined, removing configuration line");
            $self->removeConfigLine($fh,$keyword,$line_fmt);
          }
          next;
        }
    
        # Instance parameters are specific, as this is a nlist of instance
        # with the value being a nlist of parameters for the instance.
        # Also the variable name must be updated to contain the instance name.
        # One configuration line must be written/updated for each instance.
        if ( $value_fmt == LINE_VALUE_INSTANCE_PARAMS ) {
          foreach my $instance (sort keys %{$attr_value}) {
            my $params = $attr_value->{$instance};
            $self->debug(1,"$function_name: formatting instance '$instance' parameters ($params)");
            $config_value = $self->formatAttributeValue($params,
                                                        $line_fmt,
                                                        $value_fmt,
                                                       );
            my $config_param = $keyword;
            my $instance_uc = uc($instance);
            $config_param =~ s/%%INSTANCE%%/$instance_uc/;
            $self->debug(2,"New variable name generated: >>>$config_param<<<");
            $self->updateConfigLine($fh,$config_param,$config_value,$line_fmt);
          }
          $config_updated = 1;
        } elsif ( $value_fmt == LINE_VALUE_STRING_HASH ) {
          # With this value format, several lines with the same keyword are generated,
          # one for each key/value pair.
          foreach my $k (sort keys %$attr_value) {
            my $v = $attr_value->{$k};
            # Value is made by joining key and value as a string
            # Keys may be escaped if they contain characters like '/': unescaping a non-escaped
            # string is generally harmless.
            my $tmp = unescape($k)." $v";
            $self->debug(1,"$function_name: formatting (string hash) attribute '$attribute' value ($tmp, value_fmt=$value_fmt)");
            $config_value = $self->formatAttributeValue($tmp,
                                                        $line_fmt,
                                                        $value_fmt,
                                                       );
            $self->updateConfigLine($fh,$keyword,$config_value,$line_fmt,1);
          }
          $config_updated = 1;
        } elsif ( ($value_fmt == LINE_VALUE_ARRAY) && ($value_opt == LINE_VALUE_OPT_SINGLE) ) {
          # With this value format, several lines with the same keyword are generated,
          # one for each array value (if value_opt is not LINE_VALUE_OPT_SINGLE, all
          # the values are concatenated on one line).
          foreach my $val (@$attr_value) {
            $self->debug(1,"$function_name: formatting (array) attribute '$attribute' value ($val, value_fmt=".LINE_VALUE_AS_IS.")");
            $config_value = $self->formatAttributeValue($val,
                                                        $line_fmt,
                                                        LINE_VALUE_AS_IS,
                                                       );
            $self->updateConfigLine($fh,$keyword,$config_value,$line_fmt,1);            
          }
          $config_updated = 1;
        } else {
          $self->debug(1,"$function_name: formatting attribute '$attribute' value ($attr_value, value_fmt=$value_fmt)");
          $config_value .= $self->formatAttributeValue($attr_value,
                                                       $line_fmt,
                                                       $value_fmt);
          $self->debug(2,"$function_name: adding attribute '".$attribute."' from option set '".$option_set.
                                                                "' to value (config_value=".$config_value.")");
        }
      }
    } else {
      # $attribute empty means an empty rule : in this case,just write the configuration param.
      $self->debug(1,"$function_name: no attribute specified in rule '$rule'");
    }

    # Instance parameters, string hashes have already been written
    if ( !$config_updated && $attribute_present ) {
      $self->updateConfigLine($fh,$keyword,$config_value,$line_fmt);
    }  
  }

  # Update configuration file if content has changed
  $self->debug(1,"$function_name: actually updating the file...");
  my $changes = $fh->close();

  return $changes;
}


# Update a role configuration file, applying the appropriate configuration rules.
# This function retrieves the config file associated with role and then calls
# updateConfigFile() to actually do the update. It flags the service associated
# with the role for restart if the config file was changed.
#
# Arguments :
#       role: role a configuration file must be build for
#       config: hash containing the global options and the configuration of roles
sub updateRoleConfig () {
  my $function_name = "updateRoleConfig";
  my $self = shift;

  my $role = shift;
  unless ( $role ) {
    $self->error("$function_name: 'role' argument missing");
    return 1;
  }

  my $config = shift;
  unless ( $config ) {
    $self->error("$function_name: 'config' argument missing");
    return 1;
  }

  # Check if the role is enabled on local host: if not, set flag to apply only ALWAYS rules
  my %parser_options;
  $parser_options{always_rules_only} = ! (exists($config->{$role}) && $config->{$role}->{role_enabled});

  $self->debug(1,"$function_name: building configuration file for role ".uc($role)." (".${$config_files{$role}}.")");

  my $changes=$self->updateConfigFile(${$config_files{$role}},$config_rules{$role},$config,\%parser_options);

    # Keep track of services that need to be restarted if changes have been made
  if ( $changes > 0 ) {
    $self->serviceRestartNeeded($role);
  }
}


1;      # Required for PERL modules
