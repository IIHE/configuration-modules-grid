# ${license-info}
# ${developer-info}
# ${author-info}
# ${build-info}
#

package NCM::Component::pbsserver;

use strict;
use warnings;

use NCM::Component;
use vars qw(@ISA $EC);
@ISA = qw(NCM::Component);
$EC=LC::Exception::Context->new->will_store_all;
use NCM::Check;

use CAF::Process;
use CAF::Service;
use CAF::FileWriter;

use File::Copy;
use File::Path;

local(*DTA);

use constant FILTER_PBSNODES_PATTERNS => qw(
    status jobs
    mom_(manager|service)_port
    (total|dedicated)_(sockets|numa_nodes|cores|threads)
);


# Location of the qmgr binary (needs to be determined and set once)
my $qmgr;


sub Configure
{
    my ($self, $config) = @_;

    # Define paths for convenience and retrieve configuration
    my $base = "/software/components/pbsserver";
    my $tree = $config->getElement($base)->getTree();

    # set to true if service was (re)started
    my $started = 0;

    # Retrieve location for pbs working directory and ensure it exists.
    my $pbsroot = "/var/torque";
    if ( $tree->{pbsroot} ) {
        $pbsroot = $tree->{pbsroot};
    }
    mkpath($pbsroot, 0, 0755) unless (-e $pbsroot);
    if (! -d $pbsroot) {
        $self->Fail("Can't create directory: $pbsroot");
        return 1;
    }

    my $srv = CAF::Service->new(['pbs_server'], log => $self);

    # Determine the location of the pbs commands.
    my $binpath = "/usr/bin";
    if ( $tree->{binpath} ) {
        $binpath = $tree->{binpath};
    };

    my $serverdb = "$pbsroot/server_priv/serverdb";
    if (! -f $serverdb) {
        $self->info("serverdb $serverdb is missing.");
        # force is ok, because the serverdb is missing
        return 1 if (! defined($self->force_create($binpath, $pbsroot)));

        $started = 1;
        if (! $srv->start()) {
            $self->warn('pbs_server start failed after create (normal because not configured yet): '. $?);
        };
    }

    # Retrieve the contents of the envrionment file and update if necessary/
    if ( $tree->{env} ) {
        my $fname = "$pbsroot/pbs_environment";
        $self->info("Checking environment file ($fname)...");
        my $contents = "#\n# File generated by ncm-pbsserver. DO NOT EDIT\n#\n";
        foreach my $name (sort keys %{$tree->{env}}) {
            $contents .= "$name=$tree->{env}->{$name}\n";
        }
        my $result = LC::Check::file( $fname,
                                      backup => ".old",
                                      contents => $contents,
                                    );
        if ( $result < 0 ) {
            $self->error("Error updating $fname");
        } elsif ( $result > 0 ) {
            $self->verbose("$fname updated. Restarting pbs_server...");
            $started = 1;
            if (! $srv->restart()) {
                $self->error('pbs_server restart failed: '. $?);
            };
        }
    }


    # Update the submit filter.  This is used only by the qsub
    # command, so the server doesn't need to be restarted for changes
    # here.
    # Be very careful, the file will NOT work with embedded comments.
    if ( $tree->{submitfilter} ) {
        $self->info("Checking submission filter...");
        my $fname = "$pbsroot/torque.cfg";
        my $contents = "SUBMITFILTER $pbsroot/submit_filter\n";
        my $result = LC::Check::file($fname,
                                     backup => ".old",
                                     contents => $contents,
                                    );
        if ( $result < 0 ) {
            $self->error("Error updating $fname");
        } elsif ( $result > 0 ) {
            $self->log("$fname updated");
        }

        $contents = $tree->{submitfilter};
        $fname = "$pbsroot/submit_filter";
        $result = LC::Check::file($fname,
                                  backup => ".old",
                                  contents => $contents,
                                 );
        if ( $result < 0 ) {
            $self->error("Error updating $fname");
        } elsif ( $result > 0 ) {
            $self->log("$fname updated");
        }
        chmod 0755, "$fname";


    # Ensure that any existing filter is removed.  Since the
    # submitfilter is the only parameter in torque.cfg, this file
    # can be removed as well.
    # this is far from true. if something else manages torque.cfg, set ignoretorquecfg to true
    } else {
        $self->info("Removing submission filter...");
        my $removetorquecfg = 1;
        if (exists($tree->{ignoretorquecfg}) && $tree->{ignoretorquecfg}) {
            $removetorquecfg = 0;
            $self->info("Ignoring torque.cfg file.");
        };
        unlink "$pbsroot/torque.cfg" if (-e "$pbsroot/torque.cfg" && $removetorquecfg);
        unlink "$pbsroot/submit_filter" if (-e "$pbsroot/submit_filter");
    }


    $qmgr = "$binpath/qmgr";
    my $pbsnodes = "$binpath/pbsnodes";
    if (! (-x $qmgr)) {
        $self->error("$qmgr isn't executable");
        return 1;
    }
    if (! (-x $pbsnodes)) {
        $self->error("$pbsnodes isn't executable");
        return 1;
    }

    my $existing = $self->get_current_config($started);
    return 1 if (! defined($existing));


    # server configuration
    # $serverbase --+
    #               +--manualconfig : boolean
    #               +--attlist ? nlist
    # If manualconfig is false, remove any existing config parameter not part of the configuration.
    my %definedsatt;
    if ( $tree->{server} ) {
        $self->info("Updating server attributes...");
        if ( $tree->{server}->{attlist} ) {
            my $server_attlist = $tree->{server}->{attlist};
            foreach my $serveratt (sort keys %{$server_attlist}) {
                $definedsatt{$serveratt} = 1;
                $self->qmgr("set server $serveratt = ".$server_attlist->{$serveratt});
            }
        }

        # Removing server attributes not defined in configuration if manualconfig is set to false.
        # Take care of not removing a few attributes generated/maintained by the server.
        # 'acl_hosts' is defined to the server host name at startup if not explicitly defined.
        if ( $self->allowed($tree->{server}) ) {
            $self->debug(1,"Removing server attributes not part of the configuration (manualconfig=false)");
            foreach (sort keys %{$existing->{satt}}) {
                unless ( defined($definedsatt{$_}) ||
                        ($_ eq "pbs_version") ||
                        ($_ eq "acl_hosts") ||
                        ($_ eq "next_job_number") ) {
                    $self->qmgr("unset server $_");
                }
            }
        }
    }


    if ( $tree->{server}->{attlist}->{server_name} ) {
        my $fh = CAF::FileWriter->new("$pbsroot/server_name", log => $self);
        print $fh "$tree->{server}->{attlist}->{server_name}\n";
        if ($fh->close()) {
            $self->info("server_name file changed, restarting pbs_server");
            if (! $srv->restart()) {
                $self->error('pbs_server restart failed: '. $?);
            };
            # Wait till server responds again
            my $new_existing = $self->get_current_config(1);
            return 1 if (! defined($existing));
        }
    }

    # queue configuration
    # $queuebase --+
    #              +--manualconfig : boolean
    #              +--queuelist--+ ? nlist
    #                            +--manualconfig : boolean
    #                            +--attlist ? nlist
    # If manualconfig is false, remove any existing config parameter not part of the configuration.

    my %definedqueues;
    if ( $tree->{queue} ) {
        $self->info("Updating queue list and queue attributes...");
        if ( $tree->{queue}->{queuelist} ) {
            my $queuelist = $tree->{queue}->{queuelist};
            foreach my $queue (sort keys(%{$queuelist})) {
                $definedqueues{$queue} = 1;
                if (!$existing->{queues}->{$queue}) {
                    $self->qmgr("create queue $queue");
                }

                my %definedqatt;
                if ( $queuelist->{$queue}->{attlist} ) {
                    my $queue_attlist = $queuelist->{$queue}->{attlist};
                    foreach my $queueatt (sort keys(%{$queue_attlist})) {
                        $definedqatt{$queueatt} = 1;
                        # Ensure queue is enabled and started after the configuration has been done
                        if (($queueatt ne "enabled") && ($queueatt ne "started")) {
                            $self->qmgr("set queue $queue $queueatt = ".$queue_attlist->{$queueatt});
                        }
                    }
                    foreach my $queueatt ('enabled', 'started') {
                        if ( $definedqatt{$queueatt} ) {
                            $self->qmgr("set queue $queue $queueatt = ".$queue_attlist->{$queueatt});
                        }
                    }
                }

                # Removing non-defined queue attributes if manualconfig is set to false
                if ( $self->allowed($queuelist->{$queue}) ) {
                    $self->debug(1,"Removing queue $queue attributes not part of the configuration (manualconfig=false)");
                    foreach (sort keys %{$existing->{queues}->{$queue}}) {
                        $self->qmgr("unset queue $queue $_") unless (defined($definedqatt{$_}));
                    }
                }
            }
        }

        # Delete existing queues not part of the configuration if manualconfig is set to false
        if ( $self->allowed($tree->{queue}) ) {
            foreach (sort keys %{$existing->{queues}}) {
                unless (defined($definedqueues{$_})) {
                    $self->qmgr("delete queue $_", "Removing queue $_...");
                }
            }
        }
    }


    # This slurps the pbsnodes output into a hash of hashes.  This
    # avoids having to rerun the command.
    my %existingnodes;
    my $lastnode = '';
    my $filterpattern = '^(' . join('|', FILTER_PBSNODES_PATTERNS) . ')$';
    my $filterregexp = qr{$filterpattern};
    $self->verbose("pbsnodes attributes filter regexp $filterregexp");
    if (-e "$pbsroot/server_priv/nodes" && -s "$pbsroot/server_priv/nodes") {
        my $output = CAF::Process->new([$pbsnodes, '-a'], log => $self)->output();
        if ($?) {
            $self->error("error running $pbsnodes");
            return 1;
        }
        foreach (split(/\n/, $output)) {
            chomp;
            if (m/(^[\w\d\.-]+)\s*$/) {
                # Start of a section with node name.
                $lastnode = $1;
                $existingnodes{$lastnode} = {};
            } elsif (m/^\s*(\w+)\s*=\s*(.*)/) {
                # This is an attribute.  Attach it to last node.
                my $name = $1;
                my $value = $2;
                if ($lastnode && $name !~ $filterregexp) {
                    my $href = $existingnodes{$lastnode};
                    $href->{$name} = $value;
                }
            }
        }
    }

    # node configuration
    # $nodebase--+
    #            +--manualconfig : boolean
    #            +--nodelist--+ ? nlist
    #                         +--manualconfig : boolean
    #                         +--attlist ? nlist

    my %definednodes;
    if ( $tree->{node} ) {
        $self->info("Updating WN list and WN attributes...");
        if ( $tree->{node}->{nodelist} ) {
            my $nodelist = $tree->{node}->{nodelist};
            foreach my $node (sort keys %{$nodelist}) {
                $definednodes{$node} = 1;
                $self->qmgr("create node $node") unless (defined($existingnodes{$node}));

                # Retrieve node attributes and properties.
                # properties is a comma separated list.
                my %definednatt;
                my %existingnatt;
                my %defprops;
                if (defined($existingnodes{$node})) {
                    my $href = $existingnodes{$node};
                    %existingnatt = %$href;
                }
                if (defined($existingnatt{properties})) {
                    my @props = split /,/, $existingnatt{properties};
                    foreach my $p (@props) {
                        $defprops{$p} = 1;
                    }
                }

                if ( $nodelist->{$node}->{attlist} ) {
                    my $node_attlist = $nodelist->{$node}->{attlist};
                    foreach my $nodeatt (sort keys %{$node_attlist}) {
                        if ($nodeatt eq "properties") {
                            my @newprops = split /,/, $node_attlist->{$nodeatt};
                            foreach my $p (@newprops) {
                                if (defined($defprops{$p})) {
                                    delete $defprops{$p};
                                } else {
                                    $self->qmgr("set node $node $nodeatt += $p");
                                }
                            }
                        } elsif ($nodeatt ne "status") {
                            $definednatt{$nodeatt} = 1;
                            $self->qmgr("set node $node $nodeatt = ".$node_attlist->{$nodeatt});
                        }
                    }
                }

                # Removing non-defined node attributes if manualconfig is set to false
                if ( $self->allowed($nodelist->{$node}) ) {
                    $self->debug(1,"Removing node $node attributes not part of the configuration (manualconfig=false)");
                    # First delete properties not part of the configuration
                    foreach my $p (sort keys %defprops) {
                        $self->qmgr("set node $node properties -= '$p'");
                    }
                    # Delete attributes not part of the configuration, preserving special attributes
                    # like state, status or ntype.
                    foreach (sort keys %existingnatt) {
                        if (!defined($definednatt{$_}) &&
                                ($_ ne "ntype") &&
                                ($_ ne "state") &&
                                ($_ ne "power_state") &&
                                ($_ ne "properties") &&
                                ($_ ne "status")) {
                            $self->qmgr("unset node $node $_");
                        }
                    }
                }
            }
        }

        # Delete existing nodes not part of the configuration if manualconfig is set to false
        if ( $self->allowed($tree->{node}) ) {
            foreach (sort keys %existingnodes) {
                unless (defined($definednodes{$_})) {
                    $self->qmgr("delete node $_", "Removing node $_...");
                }
            }
        }
    }

    return 1;
}


# For hashref cfg, return if component is allowed to make changes
# (it checks if the manualconfig attribute is set and false)
sub allowed
{
    my ($self, $cfg) = @_;

    return defined($cfg->{manualconfig}) && (!$cfg->{manualconfig});
}


# force (re)create the serverdb
sub force_create
{
    my ($self, $binpath, $pbsroot) = @_;

    my $sleep = 10;

    my $pbs_server_bin = "$binpath";
    # it's in sbin
    $pbs_server_bin =~ s/bin/sbin/;
    $pbs_server_bin .= "/pbs_server";
    $self->info("Trying with pbs_server $pbs_server_bin");
    my $output = CAF::Process->new([$pbs_server_bin, '-d', $pbsroot, '-t', 'create', '-f'], log => $self)->output();
    if ($?) {
        $self->error("Failed to create the server (ec $?): $output");
        return;
    };
    sleep $sleep;

    my $qterm = "$binpath/qterm";
    $output = CAF::Process->new([$qterm], log => $self)->output();
    if ($?) {
        $self->error("Failed to stop the server (ec $?), trying again: $output");
        sleep 2*$sleep;
        $output = CAF::Process->new([$qterm], log => $self)->output();
        if ($?) {
            $self->error("Failed to stop the server (ec $?) 2nd time, giving up: $output");
            return;
        };
    };

    return 1;
}

# execute qmgr with command cmd
# if optional msg is passed, report the message with info level
sub qmgr
{
    my ($self, $cmd, $msg) = @_;
    $self->info($msg) if $msg;

    my $out = CAF::Process->new([$qmgr, "-c", $cmd], log => $self)->output();
    if ($?) {
	   $self->error("Failed to run $qmgr $cmd: $out (", $? >> 8, ")");
    } else {
	   $self->debug(2, "OK: $cmd");
    }
    return $out;
}

# Wait a bit for the server to become active in case it has been restarted.
# Check every 30s after the first try until it comes up; try for up to
# 5 minutes.
# Args:
#   started : start with 5 second sleep (in case recently (re)started)
# Return a hashref with server attributes and queue
# data from the current config on success; undef on failure.
sub get_current_config
{
    my ($self, $started) = @_;

    $self->info("Retrieving current configuration...");
    my $remaining = 10;
    sleep 5 if $started;
    my $current_config = $self->qmgr("print server");
    while ( $? && ($remaining > 0) ) {
        $self->log("waiting 30s for qmgr to respond; $remaining tries remaining");
        $remaining--;
        sleep 30;
        $current_config = $self->qmgr("print server");
    }
    if ( $? ) {
        $self->error("qmgr is not responding; aborting configuration");
        return;
    }

    my $existing;
    foreach (split('\n', $current_config)) {
        chomp;
        if (m/set server ([\w\.]+)/) {
            # Mark the server attribute as set.
            $existing->{satt}->{$1} = 1;

        } elsif (m/create queue ([\w\.\-]+)/) {
            # Create a hash for the queue.
            $existing->{queues}->{$1} = {};

        } elsif (m/set queue ([\w\.\-]+)\s+([\w\.]+)/) {
            # Mark the attribute as set for the given queue.
            my $queue = $1;
            my $name = $2;
            $existing->{queues}->{$queue}->{$name} = 1;
        }
    }
    return $existing;
}


1;      # Required for PERL modules
