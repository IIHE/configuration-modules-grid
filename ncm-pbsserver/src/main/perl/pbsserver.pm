# ${license-info}
# ${developer-info}
# ${author-info}
# ${build-info}
#

package NCM::Component::pbsserver;

use strict;
use NCM::Component;
use vars qw(@ISA $EC);
@ISA = qw(NCM::Component);
$EC=LC::Exception::Context->new->will_store_all;
use NCM::Check;

use EDG::WP4::CCM::Element;

use File::Copy;
use File::Path;

local(*DTA);


##########################################################################
sub Configure($$@) {
##########################################################################
    
    my ($self, $config) = @_;

    # Define paths for convenience. 
    my $base = "/software/components/pbsserver";

    # Save the date.
    my $date = localtime();

    # Default location for pbs.
    my $pbsroot = "/var/spool/pbs";
    if ($config->elementExists("$base/pbsroot")) {
        $pbsroot = $config->getValue("$base/pbsroot");
    }

    # Ensure that the directory exists or create it if not.
    mkpath($pbsroot, 0, 0755) unless (-e $pbsroot);
    if (! -d $pbsroot) {
	$self->Fail("Can't create directory: $pbsroot");
	return 1;
    }

    # Retrieve the contents of the file. 
    my $contents = "#\n# File generated by ncm-pbsserver on $date\n#\n";
    if ($config->elementExists("$base/env")) {
	my $env = $config->getElement("$base/env");
	while ( $env->hasNextElement() ) {
	    my $element = $env->getNextElement();
	    my $name = $element->getName();
	    my $value = $element->getValue();
	    $contents .= "$name=$value\n";
	}
    }

    # Write the environment file. 
    my $fname = "$pbsroot/pbs_environment";
    if ( ! -e $fname ) {
        
        # Configuration file doesn't exist yet.  Create it. 
        open CONF, ">$fname";
        print CONF $contents;
        close (CONF);
        $self->log("$fname created");
        
    } else {
        
        # Already exists. Make backup and create new file. 
        my $result = LC::Check::file( $fname,
                                      backup => ".old",
                                      contents => $contents,
                                      );
        $self->log("$fname updated") if $result;
    }

    # Update the submit filter.  This is used only by the qsub
    # command, so the server doesn't need to be restarted for changes
    # here.
    $contents = '';
    if ($config->elementExists("$base/submitfilter")) {

	# Be very careful, the file will NOT work with embedded
	# comments.
	my $contents = "SUBMITFILTER $pbsroot/submit_filter\n";

	my $fname = "$pbsroot/torque.cfg";
	if ( ! -e $fname ) {
	    
	    # Configuration file doesn't exist yet.  Create it. 
	    open CONF, ">$fname";
	    print CONF $contents;
	    close (CONF);
	    $self->log("$fname created");
	    
	} else {
	    
	    # Already exists. Make backup and create new file. 
	    my $result = LC::Check::file( $fname,
					  backup => ".old",
					  contents => $contents,
					  );
	    $self->log("$fname updated") if $result;
	}

        $contents = $config->getValue("$base/submitfilter");

	$fname = "$pbsroot/submit_filter";
	if ( ! -e $fname ) {
	    
	    # Configuration file doesn't exist yet.  Create it. 
	    open CONF, ">$fname";
	    print CONF $contents;
	    close (CONF);
	    $self->log("$fname created");
	    
	} else {
	    
	    # Already exists. Make backup and create new file. 
	    my $result = LC::Check::file( $fname,
					  backup => ".old",
					  contents => $contents,
					  );
	    $self->log("$fname updated") if $result;
	}
	chmod 0755, "$fname";

    } else {

	# Ensure that any existing filter is removed.  Since the
	# submitfilter is the only parameter in torque.cfg, this file
	# can be removed as well.
	unlink "$pbsroot/torque.cfg" if (-e "$pbsroot/torque.cfg");
	unlink "$pbsroot/submit_filter" if (-e "$pbsroot/submit_filter");
    }


    # Restart the server.  Actually this is only necessary for changes
    # in the environment, but this doesn't make a distinction. 
    if (system('/etc/init.d/pbs_server restart')) {
	$self->error('pbs_server init.d restart failed: '. $?);
    }

    # Determine the location of the pbs commands. 
    my $binpath = "/usr/bin";
    if ($config->elementExists("$base/binpath")) {
	$binpath = $config->getValue("$base/binpath");
    }
    my $qmgr = "$binpath/qmgr";
    my $pbsnodes = "$binpath/pbsnodes";
    if (! (-x $qmgr)) {
	$self->error("$qmgr isn't executable");
	return 1;
    }
    if (! (-x $pbsnodes)) {
	$self->error("$pbsnodes isn't executable");
	return 1;
    }

    # Command to retrieve the server state from torque.
    my $qmgr_state = "$qmgr -c \"print server\"";

    # Wait a bit for the server to become active.  Check every
    # 30s after the first try until it comes up; try for up to  
    # 5 minutes.
    my $remaining = 10;
    sleep 5;
    system($qmgr_state);
    while ($?) {
	$remaining--;
	if ($remaining < 0) {
	    $self->error("qmgr is not responding; aborting configuration");
	    return 1;
	} else {
	    $self->log("waiting 30s for qmgr to respond; $remaining tries remaining");
	}
	sleep 30;
	system($qmgr_state);
    }

    # Slurp the existing server and queue information into a set of
    # hashes. 
    my %existingsatt;
    my %existingqueues;
    open TEMP, "$qmgr_state | ";
    while (<TEMP>) {
	if (m/set server (\w+)/) {

	    # Mark the server attribute as set.
	    $existingsatt{$1} = 1;

	} elsif (m/create queue (\w+)/) {

	    # Create a hash for the queue.
	    $existingqueues{$1} = {};

	} elsif (m/set queue (\w+)\s+([\w\.]+)/) {

	    # Mark the attribute as set for the given queue. 
	    my $queue = $1;
	    my $name = $2;
	    my $href = $existingqueues{$queue};
	    $href->{$name} = 1;
	}
    }
    close TEMP;
    if ($?) {
	$self->error("error running $qmgr");
	return 1;
    }

    ## $serverbase --+ 
    ##               +--manualconfig : boolean
    ##               +--attlist ? nlist
    ## server configuration
    ## no create or delete is needed
    my $serverbase = "$base/server";
    my %definedsatt;
    if ($config->elementExists("$serverbase")) {
	if ($config->elementExists("$serverbase/attlist")) {
	    my $serverlist = $config->getElement("$serverbase/attlist");
	    while ( $serverlist->hasNextElement() ) {
		my $serveratt = $serverlist->getNextElement();
		my $serverattname = $serveratt->getName();
		my $serverattval = $serveratt->getValue();
		$definedsatt{$serverattname} = 1;
		## setting defined
		$self->runCommand($qmgr, "set server $serverattname = $serverattval");
	    }
	}
	## removing non-defined server attributes if manualconfig is set to false
	## checking is needed in case of no $serverbase
	if ($config->getValue("$serverbase/manualconfig") eq "false") {
	    foreach (keys %existingsatt) {
		$self->runCommand($qmgr, "unset server $_") unless (defined($definedsatt{$_}) || ( $_ eq "pbs_version") );
	    }
	}
    }
    
    ## $queuebase --+ 
    ##              +--manualconfig : boolean
    ##              +--queuelist--+ ? nlist
    ##                            +--manualconfig : boolean
    ##                            +--attlist ? nlist
    ## queue configuration
    my $queuebase = "$base/queue";
    my %definedqueues;
    if ($config->elementExists("$queuebase")) {
	if ($config->elementExists("$queuebase/queuelist")) {
	    my $queuelist = $config->getElement("$queuebase/queuelist");
	    while ( $queuelist->hasNextElement() ) {
		my $queue = $queuelist->getNextElement();
		my $queuename = $queue->getName();
		$definedqueues{$queuename} = 1;
		##create queue
		if (!defined($existingqueues{$queuename})) {
		    $self->runCommand($qmgr, "create queue $queuename");
		}
		
		my %definedqatt;
		## set attributes
		if ($config->elementExists("$queuebase/queuelist/$queuename/attlist")) {
		    my $queueattr = $config->getElement("$queuebase/queuelist/$queuename/attlist");

		    # This is a nasty hack to get the enabled and started attributes defined last. 
		    # There must be a better way to do this.
		    while ( $queueattr->hasNextElement() ) {
			my $qatt = $queueattr->getNextElement();
			my $qattname = $qatt->getName();
			my $qattval = $qatt->getValue();
			if (($qattname ne "enabled") && ($qattname ne "started")) {
			    $definedqatt{$qattname} = 1;
			    $self->runCommand($qmgr, "set queue $queuename $qattname = $qattval");
			}
		    }
		    $queueattr = $config->getElement("$queuebase/queuelist/$queuename/attlist");
		    while ( $queueattr->hasNextElement() ) {
			my $qatt = $queueattr->getNextElement();
			my $qattname = $qatt->getName();
			my $qattval = $qatt->getValue();
			if (($qattname eq "enabled") || ($qattname eq "started")) {
			    $definedqatt{$qattname} = 1;
			    $self->runCommand($qmgr, "set queue $queuename $qattname = $qattval");
			}
		    }
		}
		## no checking if manual config exists, it should if you are here
		if ($config->getValue("$queuebase/queuelist/$queuename/manualconfig") eq "false") {
		    ## removing non-defined queue attributes
		    if (defined($existingqueues{$queuename})) {
			my $href = $existingqueues{$queuename};
			my %existingqatt = %$href;
			foreach (keys %existingqatt) {
			    $self->runCommand($qmgr, "unset queue $queuename $_") unless (defined($definedqatt{$_}));
			}
		    }
		}
	    }
	}
	## all queues that are in $existingqueues but not in $definedqueues will be removed if manualconfig is set to false
	if ($config->getValue("$queuebase/manualconfig") eq "false") {
	    foreach (keys %existingqueues) {
		$self->runCommand($qmgr, "delete queue $_") unless (defined($definedqueues{$_}));
	    }
	} 
    }

    # This slurps the pbsnodes output into a hash of hashes.  This
    # avoids having to rerun the command. 
    my %existingnodes;
    my $lastnode = '';
    if (-e "$pbsroot/server_priv/nodes" && -s "$pbsroot/server_priv/nodes") {
	open TEMP, "$pbsnodes -a |";
	while (<TEMP>) {
	    
	    if (m/(^[\w\d\.-]+)\s*$/) {
		
		# Start of a section with node name.
		$lastnode = $1;
		$existingnodes{$lastnode} = {};
		
	    } elsif (m/^\s*(\w+)\s*=\s*(.*)/) {
		
		# This is an attribute.  Attach it to last node.
		my $name = $1;
		my $value = $2;
		if ($lastnode and not (($name eq "status") ||($name eq "jobs"))) {
		    my $href = $existingnodes{$lastnode};
		    $href->{$name} = $value;
		}
	    }
	}
	close TEMP;
	if ($?) {
	    $self->error("error running $pbsnodes");
	    return 1;
	}
    }

    ## $nodebase--+ 
    ##            +--manualconfig : boolean
    ##            +--nodelist--+ ? nlist
    ##                         +--manualconfig : boolean
    ##                         +--attlist ? nlist
    ## node configuration 
    my $nodebase = "$base/node";
    my %definednodes;
    if ($config->elementExists("$nodebase")) {
	if ($config->elementExists("$nodebase/nodelist")) {
	    my $nodelist = $config->getElement("$nodebase/nodelist");
	    while ( $nodelist->hasNextElement() ) {
		my $node = $nodelist->getNextElement();
		my $nodename = $node->getName();
		$definednodes{$nodename} = 1;
		##create node
		$self->runCommand($qmgr, "create node $nodename") unless (defined($existingnodes{$nodename}));

		my %definednatt;
		my %existingnatt;
		if (defined($existingnodes{$nodename})) {
		    my $href = $existingnodes{$nodename};
		    %existingnatt = %$href;
		}

		# Have to deal with the properties specially.
		my %defprops;
		if (defined($existingnatt{properties})) {
		    my @props = split /,/, $existingnatt{properties};
		    foreach my $p (@props) {
			$defprops{$p} = 1;
		    } 
		}
		
		if ($config->elementExists("$nodebase/nodelist/$nodename/attlist")) {
		    my $nodeattr = $config->getElement("$nodebase/nodelist/$nodename/attlist");
		    ## set attributes
		    while ( $nodeattr->hasNextElement() ) {
			my $natt = $nodeattr->getNextElement();
			my $nattname = $natt->getName();
			my $nattval = $natt->getValue();
			if ($nattname eq "properties") {
			    my @newprops = split /,/, $nattval;
			    foreach my $p (@newprops) {
				if (defined($defprops{$p})) {
				    delete $defprops{$p};
				} else {
				    $self->runCommand($qmgr, "set node $nodename $nattname += $p");
				}
			    }
			} elsif ($nattname ne "status") {
			    $definednatt{$nattname} = 1;
			    $self->runCommand($qmgr, "set node $nodename $nattname = $nattval");
			}
		    }
		}

		## removing non-defined node attributes (note can't remove state or ntype)
		if ($config->getValue("$nodebase/nodelist/$nodename/manualconfig") eq "false") {
		    
		    # This will contain those properties which were defined but not in
                    # the configuration.  These should be deleted. 
		    foreach my $p (keys %defprops) {
			$self->runCommand($qmgr, "set node $nodename properties -= $p");
		    }
		    
		    # Deal with the other node attributes which can be changed.  Probably
		    # the only thing left is the np attribute. 
		    foreach (keys %existingnatt) {
			if (!defined($definednatt{$_}) && 
			    ($_ ne "ntype") && 
			    ($_ ne "state") &&
			    ($_ ne "properties") &&
			    ($_ ne "status")) {
			    $self->runCommand($qmgr, "unset node $nodename $_");
			}
		    }
		}
	    }
	}

	## all nodes that are in $existingnodes but not in $definednodes will be removed if manualconfig is set to false
	if ($config->getValue("$nodebase/manualconfig") eq "false") {
	    foreach (keys %existingnodes) {
		$self->runCommand($qmgr, "delete node $_") unless (defined($definednodes{$_}));
	    }
	}
    }
    
    return 1;
}


# Convenience routine to run a command and print out the result.
sub runCommand {
    my ($self, $qmgr, $cmd) = @_;
    my $s = `$qmgr -c \"$cmd\"`;
    if ($?) {
	$self->error("ERROR (" . ($? >> 8)  . "): $cmd");
    } else {
	$self->info("OK: $cmd");
    }
}

1;      # Required for PERL modules
